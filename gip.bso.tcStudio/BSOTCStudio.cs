using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using gip.core.datamodel;
using gip.core.autocomponent;
using gip.bso.iplus;
using EnvDTE;
using EnvDTE100;
using TCatSysManagerLib;
using System.IO;
using System.Windows.Input;
using System.Text.RegularExpressions;
using System.ComponentModel;

namespace gip.bso.tcStudio
{
    [ACClassInfo(Const.PackName_VarioDevelopment, "en{'TwinCAT Studio'}de{'TwinCAT Studio'}", Global.ACKinds.TACBSO, Global.ACStorableTypes.NotStorable, false, true)]
    public class BSOTCStudio : ACBSO
    {
        #region c'tors

        public BSOTCStudio(ACClass acType, IACObject content, IACObject parentACObject, ACValueList parameter, string acIdentifier) : base(acType, content, parentACObject, parameter, acIdentifier)
        {

        }

        public override bool ACInit(Global.ACStartTypes startChildMode = Global.ACStartTypes.Automatic)
        {
            //CurrentACProject = ACProjectList.First();
            delimiter[0] = _TCdelimiter;
            return base.ACInit(startChildMode);
        }

        public override bool ACDeInit(bool deleteACClassTask = false)
        {
            CloseSolution();
            _WrongItemsNameList = null;
            _DeleteItemsList = null;
            _ACProjectManager = null;
            bool done = base.ACDeInit(deleteACClassTask);
            if (done && _BSODatabase != null)
            {
                ACObjectContextManager.DisposeAndRemove(_BSODatabase);
                _BSODatabase = null;
            }
            return done;
        }

        #endregion

        #region Private members

        private Database _BSODatabase = null;
        /// <summary>
        /// Overriden: Returns a separate database context.
        /// </summary>
        /// <value>The context as IACEntityObjectContext.</value>
        public override IACEntityObjectContext Database
        {
            get
            {
                if (_BSODatabase == null)
                    _BSODatabase = ACObjectContextManager.GetOrCreateContext<Database>(this.GetACUrl());
                return _BSODatabase;
            }
        }

        public Database Db
        {
            get
            {
                return Database as Database;
            }
        }

        ACProjectManager _ACProjectManager;
        public ACProjectManager ProjectManager
        {
            get
            {
                if (_ACProjectManager != null)
                    return _ACProjectManager;
                _ACProjectManager = new ACProjectManager(Db, Root);
                _ACProjectManager.PropertyChanged += _ACProjectManager_PropertyChanged;
                return _ACProjectManager;
            }
        }

        private void _ACProjectManager_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == ACProjectManager.CurrentProjectItemRootPropName)
                OnPropertyChanged("CurrentProjectItemRoot");
        }

        EnvDTE.DTE _DTE;

        string _TCdelimiter = "_I_";
        string[] delimiter = new string[1];

        int _PouCounter = 20;
        int _ProjectCounter = 30;
        int _CountProjectItems = 0;

        //bool _IsFirstSync = false;
        bool _IsAnyChecked = false;
        bool _deleteItems = false;
        string _acClassInfoMovedName = "";

        string _VBRegionStart = "//Variobatch-autogenerated (WARNING: Do not write any code in Variobatch autogenerated region, because that code may be lost on next synchronization!!!!)"
                                + System.Environment.NewLine +
                                "//VBRegionStart";

        private string VBRegionStart(string spaces = "")
        {
            string startRegion = spaces + "//Variobatch-autogenerated (WARNING: Do not write any code in Variobatch autogenerated region, because that code may be lost on next synchronization!!!!)"
                                + System.Environment.NewLine +
                                spaces + "//VBRegionStart";
            return startRegion;
        }

        string _VBRegionEnd = "//VBRegionEnd";
        string _4spaces = "    ";
        string _8spaces = "        ";

        const string _ReferenceTo = " REFERENCE TO ";

        List<ACClassInfoWithItems> _DeleteItemsList = new List<ACClassInfoWithItems>();
        List<string> _WrongItemsNameList = new List<string>();
        List<string> _NotAddedEdgesList = new List<string>();

        int _lastEdgeNo;

        #endregion

        #region Properties

        #region Properties -> ACProject
        /// <summary>
        /// The _ current AC project
        /// </summary>
        ACProject _CurrentACProject;
        /// <summary>
        /// Gets or sets the current AC project.
        /// </summary>
        /// <value>The current AC project.</value>
        [ACPropertyCurrent(9999, "ACProject")]
        public ACProject CurrentACProject
        {
            get
            {
                return _CurrentACProject;
            }
            set
            {
                //_IsFirstSync = false;
                if (value != null)
                {
                    _CurrentACProject = value;
                    ProjectManager.LoadACProject(CurrentACProject, ProjectTreePresentationMode, ProjectTreeVisibilityFilter, ProjectTreeCheckHandler);
                    _CountProjectItems = CountProjectItems(CurrentProjectItemRoot);
                    if (CurrentPOU != null)
                    {
                        BackgroundWorker.RunWorkerAsync("CompareProjects");
                        ShowDialog(this, DesignNameProgressBar);
                        CurrentProjectItemRootChangeInfo = new ChangeInfo(CurrentProjectItemRoot, CurrentProjectItemRoot, Const.CmdUpdateAllData);
                        OnPropertyChanged("CurrentProjectItemRoot");
                    }
                }
                else
                {
                    _CurrentACProject = null;
                    ProjectManager.EliminateProjectTree();
                }
                OnPropertyChanged("CurrentACProject");
                OnPropertyChanged("CurrentProjectItemRoot");
            }
        }

        /// <summary>
        /// Gets the AC project list.
        /// </summary>
        /// <value>The AC project list.</value>
        [ACPropertyList(9999, "ACProject")]
        public IEnumerable<ACProject> ACProjectList
        {
            get
            {
                return Db.ACProject.Where(c => c.ACProjectTypeIndex == (short)Global.ACProjectTypes.AppDefinition
                                                               || c.ACProjectTypeIndex == (short)Global.ACProjectTypes.Application);
            }
        }


        private ACClassInfoWithItems.CheckHandler _ProjectTreeCheckHandler;
        protected ACClassInfoWithItems.CheckHandler ProjectTreeCheckHandler
        {
            get
            {
                if (_ProjectTreeCheckHandler == null)
                {
                    _ProjectTreeCheckHandler = new ACClassInfoWithItems.CheckHandler()
                    {
                        IsCheckboxVisible = true,
                        //CheckedSetter = InfoItemIsCheckedSetter,
                        //CheckedGetter = InfoItemIsCheckedGetter,
                        //CheckIsEnabledGetter = InfoItemIsCheckEnabledGetter,
                    };
                }
                return _ProjectTreeCheckHandler;
            }
        }

        private Type[] _AssignableTypes = new Type[4] { typeof(PAProcessFunction), typeof(PAProcessModule), typeof(ApplicationManager), typeof(PAModule) };
        protected ACClassInfoWithItems.VisibilityFilters ProjectTreeVisibilityFilter
        {
            get
            {
                ACClassInfoWithItems.VisibilityFilters filter
                    = new ACClassInfoWithItems.VisibilityFilters()
                    {
                        IncludeProcessFunctions = true,
                        IncludeProcessModules = true,
                        IncludeModules = true,
                        //AssignableTypes = _AssignableTypes
                        //SearchText = this.SearchClassText,
                    };
                return filter;
            }
        }

        protected ACProjectManager.PresentationMode ProjectTreePresentationMode
        {
            get
            {
                ACProjectManager.PresentationMode mode
                    = new ACProjectManager.PresentationMode()
                    {
                        DisplayGroupedTree = false
                    };
                return mode;
            }
        }


        /// <summary>
        /// Gets the current project item root.
        /// </summary>
        /// <value>The current project item root.</value>
        [ACPropertyCurrent(9999, "ProjectItemRoot")]
        public ACClassInfoWithItems CurrentProjectItemRoot
        {
            get
            {
                return ProjectManager.CurrentProjectItemRoot;
            }
        }

        /// <summary>
        /// The _ current project item root change info
        /// </summary>
        ChangeInfo _CurrentProjectItemRootChangeInfo = null;
        /// <summary>
        /// Gets or sets the current project item root change info.
        /// </summary>
        /// <value>The current project item root change info.</value>
        [ACPropertyChangeInfo(9999, "ProjectItem")]
        public ChangeInfo CurrentProjectItemRootChangeInfo
        {
            get
            {
                return _CurrentProjectItemRootChangeInfo;
            }
            set
            {
                _CurrentProjectItemRootChangeInfo = value;
                OnPropertyChanged("CurrentProjectItemRootChangeInfo");
            }
        }

        /// <summary>
        /// The _ current project item
        /// </summary>
        ACClassInfoWithItems _CurrentProjectItem = null;
        /// <summary>
        /// Gets or sets the current project item.
        /// </summary>
        /// <value>The current project item.</value>
        [ACPropertyCurrent(9999, "ProjectItem")]
        public ACClassInfoWithItems CurrentProjectItem
        {
            get
            {
                return _CurrentProjectItem;
            }
            set
            {
                if (_CurrentProjectItem != value)
                {
                    _CurrentProjectItem = value;
                    if (_CurrentProjectItem != null && _CurrentProjectItem.ValueT != null)
                    {
                        ProjectItemPropertyList = LoadProperties(_CurrentProjectItem);
                        ProjectItemMethodList = LoadMethods(_CurrentProjectItem);
                    }
                    OnPropertyChanged("CurrentProjectItem");
                }
            }
        }

        #endregion

        #region Properties -> ProjectItemProperties

        private ACClassInfoWithItems _CurrentProjectItemProperty;
        /// <summary>
        /// The current project item property.
        /// </summary>
        [ACPropertyCurrent(999, "ACProjectProperty")]
        public ACClassInfoWithItems CurrentProjectItemProperty
        {
            get
            {
                return _CurrentProjectItemProperty;
            }
            set
            {
                _CurrentProjectItemProperty = value;
                OnPropertyChanged("CurrentProjectItemProperty");
            }
        }

        private List<ACClassInfoWithItems> _ProjectItemPropertyList;
        /// <summary>
        /// The current project item property list.
        /// </summary>
        [ACPropertyList(999, "ACProjectProperty")]
        public List<ACClassInfoWithItems> ProjectItemPropertyList
        {
            get
            {
                return _ProjectItemPropertyList;
            }
            set
            {
                _ProjectItemPropertyList = value;
                OnPropertyChanged("ProjectItemPropertyList");
            }
        }

        #endregion

        #region Properties -> ProjectItemMethods

        private ACClassInfoWithItems _CurrentProjectItemMethod;
        /// <summary>
        /// The current project item method.
        /// </summary>
        [ACPropertyCurrent(999, "ACProjectMethod")]
        public ACClassInfoWithItems CurrentProjectItemMethod
        {
            get
            {
                return _CurrentProjectItemMethod;
            }
            set
            {
                _CurrentProjectItemMethod = value;
                OnPropertyChanged("CurrentProjectItemMethod");
            }
        }

        private List<ACClassInfoWithItems> _ProjectItemMethodList;
        /// <summary>
        /// The project item method list.
        /// </summary>
        [ACPropertyList(999, "ACProjectMethod")]
        public List<ACClassInfoWithItems> ProjectItemMethodList
        {
            get
            {
                return _ProjectItemMethodList;
            }
            set
            {
                _ProjectItemMethodList = value;
                OnPropertyChanged("ProjectItemMethodList");
            }
        }

        #endregion

        #region Properties -> TwinCAT

        private string _TCSolutionPath;
        /// <summary>
        /// The TWINCAT solution path.
        /// </summary>
        [ACPropertyInfo(999, "", "en{'TwinCat solution (*.sln)'}de{'TwinCat solution (*.sln)'}")]
        public string TCSolutionPath
        {
            get
            {
                return _TCSolutionPath;
            }
            set
            {
                _TCSolutionPath = value;
                OnPropertyChanged("TCSolutionPath");
            }
        }

        private ACValueItem _CurrentVisualStudio;
        /// <summary>
        /// The current version of Visual studio.
        /// </summary>
        [ACPropertyCurrent(999, "VisualStudio", "en{'Visual Studio version'}de{'Visual Studio version'}")]
        public ACValueItem CurrentVisualStudio
        {
            get
            {
                return _CurrentVisualStudio;
            }
            set
            {
                _CurrentVisualStudio = value;
                OnPropertyChanged("CurrentVisualStudio");
            }
        }

        private ACValueItemList _VisualStudioList;
        /// <summary>
        /// Visual studio version list.
        /// </summary>
        [ACPropertyList(999, "VisualStudio")]
        public ACValueItemList VisualStudioList
        {
            get
            {
                if (_VisualStudioList == null)
                {
                    _VisualStudioList = new ACValueItemList("");
                    _VisualStudioList.AddEntry(new ACValueItem("Visual Studio 10", "VisualStudio.DTE.10.0", null));
                    _VisualStudioList.AddEntry(new ACValueItem("Visual Studio 13", "VisualStudio.DTE.12.0", null));
                    _VisualStudioList.AddEntry(new ACValueItem("Visual Studio 15", "VisualStudio.DTE.14.0", null));
                    _VisualStudioList.AddEntry(new ACValueItem("Visual Studio 17", "VisualStudio.DTE.15.0", null));
                }
                return _VisualStudioList;
            }
        }

        private ACValueItem _CurrentTCPLC;
        /// <summary>
        /// Current TWINCAT PLC (selected PLC).
        /// </summary>
        [ACPropertyCurrent(999, "TCPLC", "en{'Current PLC'}de{'Current PLC'}")]
        public ACValueItem CurrentTCPLC
        {
            get
            {
                return _CurrentTCPLC;
            }
            set
            {
                if (_CurrentTCPLC != value)
                {
                    _CurrentTCPLC = value;
                    if (_CurrentTCPLC != null)
                    {
                        LoadPOU();
                    }
                }

                OnPropertyChanged("CurrentTCPLC");
            }
        }

        private List<ACValueItem> _TCPLCList;
        /// <summary>
        /// List of available PLC's.
        /// </summary>
        [ACPropertyList(999, "TCPLC")]
        public List<ACValueItem> TCPLCList
        {
            get
            {
                if (_TCPLCList == null)
                    _TCPLCList = new List<ACValueItem>();
                return _TCPLCList;
            }
            set
            {
                _TCPLCList = value;
                OnPropertyChanged("TCPLCList");
            }
        }

        private string _TCProjectInfo;
        /// <summary>
        /// The name of TWINCAT project.
        /// </summary>
        [ACPropertyInfo(999, "", "en{'TwinCAT Project'}de{'TwinCAT Projekt'}")]
        public string TCProjectInfo
        {
            get
            {
                return _TCProjectInfo;
            }
            set
            {
                _TCProjectInfo = value;
                OnPropertyChanged("TCProjectInfo");
            }
        }

        ITcSysManager _TCSystemManager;
        /// <summary>
        /// The TWINCAT system manager.
        /// </summary>
        ITcSysManager TCSystemManager
        {
            get
            {
                return _TCSystemManager;
            }
            set
            {
                _TCSystemManager = value;
            }
        }

        ITcSmTreeItem _CurrentPOU;
        /// <summary>
        /// Represents the POU's folder in TWINCAT project.
        /// </summary>
        ITcSmTreeItem CurrentPOU
        {
            get
            {
                return _CurrentPOU;
            }
            set
            {
                _CurrentPOU = value;
                CurrentACProject = null;
                OnPropertyChanged("CurrentPOU");
                if (_CurrentPOU != null)
                {
                    CurrentProjectItem = CurrentProjectItemRoot;
                    CurrentProjectItemRootChangeInfo = new ChangeInfo(null, CurrentProjectItemRoot, Const.CmdUpdateAllData);
                    CurrentProjectItemRootChangeInfo = new ChangeInfo(null, CurrentProjectItemRoot, Const.CmdDeleteData);
                }
            }
        }

        #endregion

        #endregion

        #region Methods

        #region Methods -> Load

        /// <summary>
        /// Open TWINCAT solution path.
        /// </summary>
        [ACMethodInfo("", "en{'...'}de{'...'}", 999)]
        public void OpenSolutionPath()
        {
            string tsSlnPath = Messages.OpenFileDialog("");
            if (tsSlnPath != null && tsSlnPath.ToLower().Contains(".sln"))
                TCSolutionPath = tsSlnPath;

            string line = "";
            if (string.IsNullOrEmpty(TCSolutionPath))
                return;
            using (StreamReader reader = new StreamReader(TCSolutionPath))
            {
                for (int i = 0; i < 35; i++)
                {
                    line = reader.ReadLine();
                    if (line == null)
                        return;
                    if (line.Contains("VisualStudioVersion"))
                        break;
                }
            }
            try
            {
                string version = line.Split('=').LastOrDefault().Split('.').FirstOrDefault().Trim();
                CurrentVisualStudio = VisualStudioList.FirstOrDefault(c => c.Value.ToString() == string.Format("VisualStudio.DTE.{0}.0", version));
            }
            catch (Exception ec)
            {
                CurrentVisualStudio = null;

                string msg = ec.Message;
                if (ec.InnerException != null && ec.InnerException.Message != null)
                    msg += " Inner:" + ec.InnerException.Message;

                Messages.LogException("BSOTCStudio", "OpenSolutionPath", msg);
            }
        }

        public bool IsEnabledOpenSolutionPath()
        {
            if (_DTE == null)
                return true;
            return false;
        }

        /// <summary>
        /// Load TWINCAT solution.
        /// </summary>
        [ACMethodInfo("", "en{'Load solution'}de{'Load solution'}", 999)]
        public void LoadSolution()
        {
            if (TCSolutionPath != null && TCSolutionPath.ToLower().Contains(".sln"))
            {
                if (CurrentVisualStudio != null && !BackgroundWorker.IsBusy)
                {
                    BackgroundWorker.WorkerReportsProgress = true;
                    BackgroundWorker.RunWorkerAsync("OpenSolution");
                    ShowDialog(this, DesignNameProgressBar);
                }
            }
            else
                Messages.Warning(this, "en{'Wrong type of file!'}de{'Wrong type of file!'}");
        }

        public bool IsEnabledLoadSolution()
        {
            if (_DTE == null)
                return true;
            else return false;
        }

        [ACMethodInfo("", "en{'Unload solution'}de{'Unload solution'}", 999)]
        public void UnloadSolution()
        {
            CloseSolution();
        }

        public bool IsEnabledUnloadSolution()
        {
            if (_DTE != null)
                return true;
            return false;
        }

        /// <summary>
        /// Open TWINCAT solution in visual studio(background mode). 
        /// </summary>
        /// <returns>True if solution open.</returns>
        public bool OpenSolution()
        {
            CurrentProgressInfo.TotalProgress.ProgressRangeFrom = 0;
            CurrentProgressInfo.TotalProgress.ProgressRangeTo = 100;

            CurrentProgressInfo.TotalProgress.ProgressText = "Opening Visual studio in background.";
            Type t = Type.GetTypeFromProgID(CurrentVisualStudio.Value.ToString());
            _DTE = Activator.CreateInstance(t) as DTE;
            _DTE.SuppressUI = false;
            _DTE.MainWindow.Visible = false;
            MessageFilter.Register();
            CurrentProgressInfo.TotalProgress.ProgressCurrent = 35;

            CurrentProgressInfo.TotalProgress.ProgressText = "Loading solution.";
            _DTE.Solution.Open(TCSolutionPath);
            CurrentProgressInfo.TotalProgress.ProgressCurrent = 85;

            CurrentProgressInfo.TotalProgress.ProgressText = "Loading project.";

            dynamic proj = LoadProject();

            bool isFinished = false;
            int counter = 0;

            while (!isFinished && counter < 100)
            {
                try
                {
                    TCSystemManager = proj.Object;
                    TCProjectInfo = proj.Name;
                    isFinished = true;
                }
                catch (Exception ec)
                {
                    System.Threading.Thread.Sleep(100);
                    counter++;
                    if (counter > 98)
                    {
                        string msg = ec.Message;
                        if (ec.InnerException != null && ec.InnerException.Message != null)
                            msg += " Inner:" + ec.InnerException.Message;

                        Messages.LogException("BSOTCStudio", "OpenSolution", msg);
                    }
                }
            }

            ITcSmTreeItem plc = TCSystemManager.LookupTreeItem("TIPC");

            _TCPLCList = new List<ACValueItem>();
            foreach (ITcSmTreeItem item in ITcSmTreeItemList(plc))
            {
                _TCPLCList.Add(new ACValueItem(ITCAction(() => item.Name), ITCAction(() => item.Name), null));
            }
            System.Threading.Thread.Sleep(500);
            TCPLCList = _TCPLCList.ToList();
            return true;
        }

        /// <summary>
        /// Load the TWINCAT project.
        /// </summary>
        /// <returns>Project if load successfully, else return null.</returns>
        private dynamic LoadProject()
        {
            try
            {
                _ProjectCounter--;
                System.Threading.Thread.Sleep(2000);
                dynamic proj = _DTE.Solution.Projects.Item(1);
                _ProjectCounter = 30;
                return proj;
            }
            catch (Exception ec)
            {
                if (_ProjectCounter > 0)
                    return LoadProject();
                else
                {
                    string msg = ec.Message;
                    if (ec.InnerException != null && ec.InnerException.Message != null)
                        msg += " Inner:" + ec.InnerException.Message;

                    Messages.LogException("BSOTCStudio", "LoadProject", msg);

                    return null;
                }
            }
        }

        /// <summary>
        /// Load's the POU's folder, depends on CurrentPLC(selected PLC in BSOTC3Sync).
        /// </summary>
        private void LoadPOU()
        {
            try
            {
                _PouCounter--;
                CurrentPOU = TCSystemManager.LookupTreeItem("TIPC^" + _CurrentTCPLC.ACCaption + "^" + _CurrentTCPLC.ACCaption + " Project^POUs");
                _PouCounter = 20;
            }
            catch (Exception e)
            {
                if (_PouCounter > 0)
                {
                    System.Threading.Thread.Sleep(1000);
                    LoadPOU();
                }
                else
                    Messages.Exception(this, "PLC load error: " + e.Message);
            }

        }

        /// <summary>
        /// Load properties from acClass and compare with synchronized properties in the corresponding POU. 
        /// </summary>
        /// <param name="parent">The parent properties acClass.</param>
        /// <returns>List of properties in ACClassInfoWithItems wrapper.</returns>
        private List<ACClassInfoWithItems> LoadProperties(ACClassInfoWithItems parent)
        {
            if (parent.IconState == null)
                return null;

            List<ACClassInfoWithItems> tempList = new List<ACClassInfoWithItems>();

            if ((Global.ChangeTypeEnum)parent.IconState == Global.ChangeTypeEnum.Added)
            {
                foreach (ACClassProperty acClassProperty in ((ACClass)parent.Value).ACClassProperty_ACClass.Where(c => c.IsRPCEnabled))
                    tempList.Add(new ACClassInfoWithItems() { ACCaption = acClassProperty.ACIdentifier, IconState = Global.ChangeTypeEnum.Added });
            }
            else
            {
                int count = 0;
                string name = GeneratePouPathToRoot(parent);
                ITcSmTreeItem pou = FindTreeItem(name, CurrentPOU);
                if (pou == null)
                    return tempList;
                if (ITCAction(() => pou.ItemType) == (int)ItemType.Folder)
                    pou = FindTreeItem(name, pou);

                if (pou != null)
                {
                    foreach (ITcSmTreeItem tcProp in ITcSmTreeItemList(pou))
                    {
                        string itemName = ITCAction(() => tcProp.Name);
                        if (ITCAction(() => tcProp.ItemType) == (int)ItemType.Property && !CheckIsItemUserDefined(itemName))
                        {
                            ACClassProperty acClassProperty = ((ACClass)parent.ValueT).ACClassProperty_ACClass.FirstOrDefault(c => c.ACIdentifier == itemName);
                            if (acClassProperty != null)
                            {
                                tempList.Add(new ACClassInfoWithItems() { ACCaption = acClassProperty.ACIdentifier, IconState = Global.ChangeTypeEnum.None });
                                count++;
                            }
                            else
                            {
                                tempList.Add(new ACClassInfoWithItems() { ACCaption = itemName, IconState = Global.ChangeTypeEnum.Removed });
                            }
                        }
                    }
                    if (count < parent.ValueT.ACClassProperty_ACClass.Count(c => c.IsRPCEnabled))
                    {
                        foreach (ACClassProperty acProp in parent.ValueT.ACClassProperty_ACClass.Where(c => c.IsRPCEnabled))
                        {
                            if (tempList.FirstOrDefault(c => c.ACIdentifier == acProp.ACIdentifier) == null)
                                tempList.Add(new ACClassInfoWithItems() { ACCaption = acProp.ACIdentifier, IconState = Global.ChangeTypeEnum.Added });
                        }
                    }
                }
            }

            return tempList;
        }

        /// <summary>
        /// Load methods from acClass and compare with synchronized methods in the corresponding POU. 
        /// </summary>
        /// <param name="parent">The parent methods acClass.</param>
        /// <returns>List of methods in ACClassInfoWithItems wrapper.</returns>
        private List<ACClassInfoWithItems> LoadMethods(ACClassInfoWithItems parent)
        {
            if (parent.IconState == null)
                return null;

            List<ACClassInfoWithItems> tempList = new List<ACClassInfoWithItems>();

            if ((Global.ChangeTypeEnum)parent.IconState == Global.ChangeTypeEnum.Added)
            {
                foreach (ACClassMethod acClassMethod in parent.ValueT.ACClassMethod_ACClass.Where(c => c.IsRPCEnabled))
                    tempList.Add(new ACClassInfoWithItems() { ACCaption = acClassMethod.ACIdentifier, IconState = Global.ChangeTypeEnum.Added });
            }
            else
            {
                int count = 0;
                string name = GeneratePouPathToRoot(parent);
                ITcSmTreeItem pou = FindTreeItem(name, CurrentPOU);
                if (pou == null)
                    return tempList;

                if (ITCAction(() => pou.ItemType) == (int)ItemType.Folder)
                    pou = FindTreeItem(name, pou);

                if (pou != null)
                {
                    foreach (ITcSmTreeItem tcMethod in ITcSmTreeItemList(pou))
                    {
                        string itemName = ITCAction(() => tcMethod.Name);
                        if (ITCAction(() => tcMethod.ItemType) == (int)ItemType.Method && itemName != "FB_init" && itemName != "FB_reinit" && itemName != "FB_exit"
                                                                      && itemName != "FB_postinit" && itemName != "OnMainEnter" && itemName != "OnMainExit" && itemName != "FB_childinit"
                                                                      && !CheckIsItemUserDefined(itemName))
                        {
                            ACClassMethod acClassMethod = parent.ValueT.ACClassMethod_ACClass.FirstOrDefault(c => c.ACIdentifier == itemName);
                            if (acClassMethod != null)
                            {
                                tempList.Add(new ACClassInfoWithItems() { ACCaption = acClassMethod.ACIdentifier, IconState = Global.ChangeTypeEnum.None });
                                count++;
                            }
                            else
                                tempList.Add(new ACClassInfoWithItems() { ACCaption = itemName, IconState = Global.ChangeTypeEnum.Removed });
                        }
                    }
                    if (count < parent.ValueT.ACClassMethod_ACClass.Count(c => c.IsRPCEnabled))
                    {
                        foreach (ACClassMethod tcMethod in parent.ValueT.ACClassMethod_ACClass.Where(c => c.IsRPCEnabled))
                        {
                            if (tempList.FirstOrDefault(c => c.ACIdentifier == tcMethod.ACIdentifier) == null)
                                tempList.Add(new ACClassInfoWithItems() { ACCaption = tcMethod.ACIdentifier, IconState = Global.ChangeTypeEnum.Added });
                        }
                    }
                }
            }

            return tempList;
        }

        private void CloseSolution()
        {
            if (_DTE != null)
            {
                MessageFilter.Revoke();
                _DTE.Solution.Close();
                _DTE.Quit();
                _DTE = null;
            }
            _WrongItemsNameList.Clear();
            _DeleteItemsList.Clear();
            CurrentACProject = null;
            CurrentProjectItem = null;
            CurrentTCPLC = null;
            CurrentPOU = null;
            TCProjectInfo = null;
            ProjectItemPropertyList = null;
            ProjectItemMethodList = null;
        }

        #endregion

        #region Methods -> Compare

        /// <summary>
        /// Comparing Variobatch and TWINCAT projects, and determine differences between this two projects.
        /// </summary>
        /// <param name="currentInfo">The Variobatch project item (acClass)</param>
        /// <param name="currentTreeItem">The TWINCAT project item (POU)</param>
        private void CompareProjects(ACClassInfoWithItems currentInfo, ITcSmTreeItem currentTreeItem)
        {
            CurrentProgressInfo.TotalProgress.ProgressRangeFrom = 0;
            CurrentProgressInfo.TotalProgress.ProgressRangeTo = _CountProjectItems;
            CurrentProgressInfo.TotalProgress.ProgressText = "Comparing projects...";
            MessageFilter.Register();

            foreach (ITcSmTreeItem item in ITcSmTreeItemList(currentTreeItem))
            {
                if (ITCAction(() => item.Name) == currentInfo.ACIdentifier)
                {
                    SetAllToNone(currentInfo);
                    CompareProjectRecursive(currentInfo, item, currentInfo.ACIdentifier);
                    CompareTCProject(item, currentInfo);

                    ITcSmTreeItem child = FindTreeItem(currentInfo.ACIdentifier, item);
                    if (child != null)
                    {
                        CompareProperties(currentInfo, child);
                        CompareMethods(currentInfo, child);
                    }
                    return;
                }
            }
            MessageFilter.Revoke();
            SetAllToAdded(currentInfo);
            //_IsFirstSync = true;
        }

        /// <summary>
        /// Compare projects recursive.
        /// </summary>
        /// <param name="currentInfo">Current ACClassInfoWithItems (acClass).</param>
        /// <param name="currentTreeItem">Current POU.</param>
        /// <param name="parentName">The POU name.</param>
        private void CompareProjectRecursive(ACClassInfoWithItems currentInfo, ITcSmTreeItem currentTreeItem, string parentName)
        {
            CurrentProgressInfo.TotalProgress.ProgressCurrent++;
            foreach (ACClassInfoWithItems infoItem in currentInfo.Items)
            {
                if (!infoItem.IsVisible)
                    continue;

                string name = parentName + _TCdelimiter + infoItem.ACIdentifier;
                if (infoItem.Items.Any())
                {
                    ITcSmTreeItem folder = FindTreeItem(infoItem.ACIdentifier, currentTreeItem);
                    ITcSmTreeItem treeItem = null;

                    if (folder != null)
                        treeItem = FindTreeItem(parentName + _TCdelimiter + infoItem.ACIdentifier, folder);
                    else
                        treeItem = FindTreeItem(parentName + _TCdelimiter + infoItem.ACIdentifier, currentTreeItem);

                    if (folder == null && treeItem == null)
                    {
                        infoItem.IconState = Global.ChangeTypeEnum.Added;
                        SetAllToAdded(infoItem);
                        if ((Global.ChangeTypeEnum)currentInfo.IconState == Global.ChangeTypeEnum.None)
                            currentInfo.IconState = Global.ChangeTypeEnum.Changed;
                        while (currentInfo.ParentACObject != null && currentInfo.ParentACObject is ACClassInfoWithItems &&
                            (Global.ChangeTypeEnum)((ACClassInfoWithItems)currentInfo.ParentACObject).IconState == Global.ChangeTypeEnum.None)
                        {
                            currentInfo = currentInfo.ParentACObject as ACClassInfoWithItems;
                            currentInfo.IconState = Global.ChangeTypeEnum.Changed;
                        }
                    }
                    else if (folder != null)
                    {
                        infoItem.IconState = Global.ChangeTypeEnum.None;
                        CompareProjectRecursive(infoItem, folder, name);
                        CompareTCProject(folder, infoItem);
                        if ((Global.ChangeTypeEnum)infoItem.IconState != Global.ChangeTypeEnum.None)
                            if (infoItem.ParentACObject != null && infoItem.ParentACObject is ACClassInfoWithItems
                                                                && (Global.ChangeTypeEnum)((ACClassInfoWithItems)infoItem.ParentACObject).IconState == Global.ChangeTypeEnum.None)
                                ((ACClassInfoWithItems)infoItem.ParentACObject).IconState = Global.ChangeTypeEnum.Changed;
                    }
                    else if (folder == null && treeItem != null)
                    {
                        //set childs change type to added
                        SetAllToAdded(infoItem);
                        infoItem.IconState = Global.ChangeTypeEnum.Changed;
                        if ((Global.ChangeTypeEnum)currentInfo.IconState == Global.ChangeTypeEnum.None)
                            currentInfo.IconState = Global.ChangeTypeEnum.Changed;
                        while (currentInfo.ParentACObject != null && currentInfo.ParentACObject is ACClassInfoWithItems && (Global.ChangeTypeEnum)((ACClassInfoWithItems)currentInfo.ParentACObject).IconState == Global.ChangeTypeEnum.None)
                        {
                            currentInfo = currentInfo.ParentACObject as ACClassInfoWithItems;
                            currentInfo.IconState = Global.ChangeTypeEnum.Changed;
                        }
                    }

                    if (folder != null && treeItem != null)
                    {
                        CompareProperties(infoItem, treeItem);
                        CompareMethods(infoItem, treeItem);
                    }
                }
                else
                {
                    CurrentProgressInfo.TotalProgress.ProgressCurrent++;
                    ITcSmTreeItem tcFolder = FindTreeItem(infoItem.ACIdentifier, currentTreeItem);
                    ITcSmTreeItem treeItem = FindTreeItem(name, currentTreeItem);
                    if (tcFolder != null)
                    {
                        CompareTCProject(tcFolder, infoItem);
                        infoItem.IconState = Global.ChangeTypeEnum.Changed;
                    }
                    else if (treeItem == null)
                    {
                        infoItem.IconState = Global.ChangeTypeEnum.Added;
                        if (infoItem.ParentACObject != null && infoItem.ParentACObject is ACClassInfoWithItems
                                                            && (Global.ChangeTypeEnum)((ACClassInfoWithItems)infoItem.ParentACObject).IconState == Global.ChangeTypeEnum.None)
                            ((ACClassInfoWithItems)infoItem.ParentACObject).IconState = Global.ChangeTypeEnum.Changed;
                    }
                    else
                    {
                        infoItem.IconState = Global.ChangeTypeEnum.None;
                        CompareProperties(infoItem, treeItem);
                        if ((Global.ChangeTypeEnum)infoItem.IconState != Global.ChangeTypeEnum.Changed)
                            CompareMethods(infoItem, treeItem);
                    }
                }
            }
        }

        /// <summary>
        /// Check if any item exist in TWINCAT project but not in Variobatch project, if item exist than this method add missing item in Variobatch project tree and mark it with minus.
        /// </summary>
        /// <param name="treeItem">Current POU.</param>
        /// <param name="currentInfo">Current ACClassInfoWithItem (acClass)</param>
        private void CompareTCProject(ITcSmTreeItem treeItem, ACClassInfoWithItems currentInfo)
        {
            ACClassInfoWithItems tempInfo = currentInfo;
            if (ITCSmTreeItemChildCount(treeItem) - 1 > currentInfo.Items.OfType<ACClassInfoWithItems>().Count(c => (Global.ChangeTypeEnum)c.IconState != Global.ChangeTypeEnum.Added))
            {
                foreach (ITcSmTreeItem tItem in ITcSmTreeItemList(treeItem))
                {
                    if (ITCAction(() => tItem.ItemType) == (int)ItemType.Method)
                        continue;

                    string tItemName = ITCAction(() => tItem.Name).Split(delimiter, StringSplitOptions.RemoveEmptyEntries).LastOrDefault();
                    if (CheckIsItemUserDefined(tItemName))
                        continue;

                    var acclassinfo = currentInfo.Items.OfType<ACClassInfoWithItems>().FirstOrDefault(c => c.ACIdentifier == tItemName);

                    if (acclassinfo == null && tItemName != currentInfo.ACIdentifier)
                    {
                        ACClassInfoWithItems newInfo = new ACClassInfoWithItems()
                        {
                            ACCaption = tItemName,
                            IconState = Global.ChangeTypeEnum.Removed,
                            IsEnabled = true,
                            DataContentCheckBox = "IsChecked"
                        };
                        currentInfo.Add(newInfo);
                        AddTCProjectChilds(tItem, newInfo);

                        if ((Global.ChangeTypeEnum)currentInfo.IconState == Global.ChangeTypeEnum.None)
                            currentInfo.IconState = Global.ChangeTypeEnum.Changed;

                        while (tempInfo.ParentACObject != null && tempInfo.ParentACObject is ACClassInfoWithItems &&
                            (Global.ChangeTypeEnum)((ACClassInfoWithItems)tempInfo.ParentACObject).IconState == Global.ChangeTypeEnum.None)
                        {
                            tempInfo = tempInfo.ParentACObject as ACClassInfoWithItems;
                            tempInfo.IconState = Global.ChangeTypeEnum.Changed;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Compare properties.
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="treeItem"></param>
        private void CompareProperties(ACClassInfoWithItems parent, ITcSmTreeItem treeItem)
        {
            int countFounded = 0, countTreeItemProp = 0;
            foreach (ITcSmTreeItem item in ITcSmTreeItemList(treeItem))
            {
                string itemName = ITCAction(() => item.Name);
                if (ITCAction(() => item.ItemType) == (int)ItemType.Property && !CheckIsItemUserDefined(itemName))
                {
                    ACClassProperty acClassProperty = ((ACClass)parent.ValueT).ACClassProperty_ACClass.FirstOrDefault(c => c.ACIdentifier == itemName);
                    if (acClassProperty != null)
                    {
                        countFounded++;
                    }
                    countTreeItemProp++;
                }
            }
            if (countFounded != parent.ValueT.ACClassProperty_ACClass.Count(c => c.IsRPCEnabled) || countFounded != countTreeItemProp)
                parent.IconState = Global.ChangeTypeEnum.Changed;
        }

        /// <summary>
        /// Compare methods.
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="treeItem"></param>
        private void CompareMethods(ACClassInfoWithItems parent, ITcSmTreeItem treeItem)
        {
            int countFounded = 0, countTreeItemMethod = 0;
            foreach (ITcSmTreeItem item in ITcSmTreeItemList(treeItem))
            {
                string itemName = ITCAction(() => item.Name);
                if (ITCAction(() => item.ItemType) == (int)ItemType.Method && itemName != "FB_init" && itemName != "FB_reinit" && itemName != "FB_exit"
                                                          && itemName != "FB_postinit" && itemName != "OnMainEnter" && itemName != "OnMainExit" && itemName != "FB_childinit"
                                                          && !CheckIsItemUserDefined(itemName))
                {
                    ACClassMethod acClassMethod = parent.ValueT.ACClassMethod_ACClass.FirstOrDefault(c => c.ACIdentifier == itemName);
                    if (acClassMethod != null)
                        countFounded++;

                    countTreeItemMethod++;
                }
            }
            if (countFounded != parent.ValueT.ACClassMethod_ACClass.Count(c => c.IsRPCEnabled) || countFounded != countTreeItemMethod)
                parent.IconState = Global.ChangeTypeEnum.Changed;
        }

        /// <summary>
        /// Add missing child recursive in currentInfo (Variobatch project). 
        /// </summary>
        /// <param name="treeItem">The TWINCAT element.</param>
        /// <param name="currentInfo">The current ACClassInfoWithItems (acClass).</param>
        private void AddTCProjectChilds(ITcSmTreeItem treeItem, ACClassInfoWithItems currentInfo)
        {
            foreach (ITcSmTreeItem item in ITcSmTreeItemList(treeItem))
            {
                if (ITCAction(() => item.ItemType) == (int)ItemType.Method)
                    continue;

                string tItemName = ITCAction(() => item.Name).Split(delimiter, StringSplitOptions.RemoveEmptyEntries).LastOrDefault();
                if (currentInfo.ACIdentifier != tItemName)
                {
                    ACClassInfoWithItems newInfo = new ACClassInfoWithItems()
                    {
                        ACCaption = tItemName,
                        IconState = Global.ChangeTypeEnum.Removed,
                        IsEnabled = true,
                        DataContentCheckBox = "IsChecked"
                    };
                    currentInfo.Add(newInfo);
                    AddTCProjectChilds(item, newInfo);
                }
            }
        }

        /// <summary>
        /// Check if pou, method or property is user defined. (Item name finished with XX. e.g.: TestMethodXX)
        /// </summary>
        /// <param name="itemName">The item name.</param>
        /// <returns>True if user defined otherwise return false.</returns>
        private bool CheckIsItemUserDefined(string itemName)
        {
            return itemName.Substring(itemName.Length - 2) == "XX";
        }

        #endregion

        #region Methods -> Sync

        /// <summary>
        /// Start synchronize projects.
        /// </summary>
        [ACMethodInfo("", "en{'Synchronize project'}de{'Synchronize project'}", 999)]
        public void SyncProjects()
        {
            _WrongItemsNameList.Clear();
            _NotAddedEdgesList.Clear();
            CheckProjectItemsName(CurrentProjectItemRoot);

            if (_WrongItemsNameList.Any())
            {
                string msg = "Item name can contain only letters, numbers and underscore, next items has incorrect name:";
                _WrongItemsNameList.ForEach(c => msg += System.Environment.NewLine + c);
                Messages.Warning(this, msg);
            }
            else
            {
                _IsAnyChecked = CheckIsAnyChecked(CurrentProjectItemRoot);
                CheckIsAnyProjectItemForDelete(CurrentProjectItemRoot);
                BackgroundWorker.RunWorkerAsync("SyncProjects");
                ShowDialog(this, DesignNameProgressBar);
                foreach (var item in _DeleteItemsList)
                {
                    CurrentProjectItem = item;
                    CheckAndSetChangeInfo(item.ParentACObject as ACClassInfoWithItems);
                    CurrentProjectItemRootChangeInfo = new ChangeInfo(null, item, Const.CmdUpdateAllData);
                    CurrentProjectItemRootChangeInfo = new ChangeInfo(item.ParentACObject, item, Const.CmdDeleteData);
                }
                ProjectManager.RefreshProjectTree(this.ProjectTreePresentationMode, this.ProjectTreeVisibilityFilter, this.ProjectTreeCheckHandler);
                if (_NotAddedEdgesList.Any())
                {
                    string msg = "Add edges error:";
                    _NotAddedEdgesList.ForEach(c => msg += System.Environment.NewLine + c);
                    Messages.Warning(this, msg);
                }
            }
        }

        /// <summary>
        /// Is enabled synchronize projects.
        /// </summary>
        /// <returns></returns>
        public bool IsEnabledSyncProjects()
        {
            if (BackgroundWorker.IsBusy || CurrentTCPLC == null || CurrentACProject == null)
                return false;
            return true;
        }

        /// <summary>
        /// Check recursive if any project item marked with minus and will be deleted on next synchronization and set _deleteItems flag.
        /// </summary>
        /// <param name="info">Current ACClassInfoWithItems (acClass).</param>
        /// <returns>True if any item will be deleted, else return false.</returns>
        private bool CheckIsAnyProjectItemForDelete(ACClassInfoWithItems info)
        {
            foreach (ACClassInfoWithItems element in info.Items)
            {
                if (((Global.ChangeTypeEnum)element.IconState == Global.ChangeTypeEnum.Removed && !_IsAnyChecked))
                {
                    if (Messages.Question(this, "Question50031") == Global.MsgResult.Yes)
                        _deleteItems = true;
                    return true;
                }
                else if (((Global.ChangeTypeEnum)element.IconState == Global.ChangeTypeEnum.Removed && _IsAnyChecked && element.IsChecked))
                {
                    if (Messages.Question(this, "Question50032") == Global.MsgResult.Yes)
                        _deleteItems = true;
                    return true;
                }
                if (CheckIsAnyProjectItemForDelete(element))
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Synchronize root project item and save TWINCAT project after successful synchronization.
        /// </summary>
        private void SyncProj()
        {
            _mainDecl = "";
            if (CurrentACProject.ACProjectType == Global.ACProjectTypes.Application)
            {
                ITcSmTreeItem main = FindTreeItem("MAIN", CurrentPOU);
                string decl = ITCAction(() => main is ITcPlcDeclaration ? ((ITcPlcDeclaration)main).DeclarationText : "");

                int startIndex = decl.IndexOf("//VBRegionStart");
                int endIndex = decl.IndexOf(_VBRegionEnd);

                if (startIndex != -1 && endIndex != -1)
                {
                    string declVB = decl.Substring(startIndex, endIndex - startIndex).Trim();
                    int edgeIndex = declVB.IndexOf("_Edge");

                    if(edgeIndex != -1)
                    {
                        _mainDecl = declVB.Substring("//VBRegionStart".Length, edgeIndex - "//VBRegionStart".Length).Trim();
                        _mainEdgeDecl = declVB.Substring(edgeIndex, declVB.Length - edgeIndex);
                        int lastEdgeIndex = _mainEdgeDecl.LastIndexOf("_Edge");
                        string lastEdge = _mainEdgeDecl.Substring(lastEdgeIndex + 5, 4);
                        int.TryParse(lastEdge, out _lastEdgeNo);
                    }
                    else
                    {
                        _mainDecl = declVB.Substring("//VBRegionStart".Length, declVB.IndexOf(_VBRegionEnd));
                    }
                }
            }

            CurrentProgressInfo.TotalProgress.ProgressRangeFrom = 0;
            CurrentProgressInfo.TotalProgress.ProgressRangeTo = _CountProjectItems;
            CurrentProgressInfo.TotalProgress.ProgressText = "Sync starting...";
            CurrentProgressInfo.TotalProgress.ProgressCurrent = 0;

            _DeleteItemsList.Clear();

            bool newFolder;
            ITcSmTreeItem folder = CheckOrMakeFolder(CurrentPOU, CurrentProjectItemRoot, out newFolder);
            CheckOrMakePOU(folder, CurrentProjectItemRoot, CurrentProjectItemRoot.ACIdentifier);
            UpdatePropertiesAndMethods(CurrentProjectItemRoot);
            CurrentProjectItemRoot.IconState = Global.ChangeTypeEnum.None;
            CurrentProgressInfo.TotalProgress.ProgressCurrent = 1;

            _edgeDeleteCache = new List<Tuple<string, string>>();
            _pouDeleteCache = new List<string>();

            if (!_IsAnyChecked)
            {
                SyncRecursive(folder, CurrentProjectItemRoot, ITCAction(() => folder.Name));
                SetAllToNone(CurrentProjectItemRoot);
                CreateComponentConnection(CurrentProjectItemRoot, CurrentProjectItemRoot.ACIdentifier);
            }
            else
            {
                CurrentProgressInfo.TotalProgress.ProgressRangeTo = CountProjectItems(CurrentProjectItem, true);
                SyncRecursiveChecked(CurrentProjectItemRoot, CurrentProjectItemRoot.ACIdentifier);
                CreateComponentConnection(CurrentProjectItemRoot, CurrentProjectItemRoot.ACIdentifier, true);
            }

            if (CurrentACProject.ACProjectType == Global.ACProjectTypes.Application)
            {
                ITcSmTreeItem main = FindTreeItem("MAIN", CurrentPOU);
                RemoveDeletedItemsFromMain(main);
                AddMainDeclarationAndImplementation(main, CurrentProjectItemRoot.ACIdentifier);
            }

            ProjectItemPropertyList = LoadProperties(CurrentProjectItem);
            ProjectItemMethodList = LoadMethods(CurrentProjectItem);

            Projects pr = ITCAction<Projects>(() => _DTE.Solution.Projects, 500);
            Project prItem = ITCAction<Project>(() => pr.Item(1), 500);
            ITCAction(() => prItem.Save(), 500);
        }

        /// <summary>
        /// Synchronize projects recursive on first synchronization or when niether item is marked with tick.
        /// </summary>
        /// <param name="parent">The PLC folder.</param>
        /// <param name="info">The current ACClassInfoWithItems (acClass).</param>
        /// <param name="parentName">The POU name.</param>
        private void SyncRecursive(ITcSmTreeItem parent, ACClassInfoWithItems info, string parentName)
        {
            foreach (ACClassInfoWithItems element in info.Items)
            {
                if (!element.IsVisible)
                    continue;

                string pouName = parentName + _TCdelimiter + element.ACIdentifier;

                if ((Global.ChangeTypeEnum)element.IconState == Global.ChangeTypeEnum.Removed && _deleteItems && !_IsAnyChecked)
                {
                    ITcSmTreeItem item = FindTreeItem(pouName, parent);
                    ResolveEdgesForDelete(item);
                    DeleteFolderOrPou(element, parent, pouName);
                    DeleteFromImplementationAndDeclaration(pouName, parent);
                    CheckAndMoveAfterDelete(parent, element.ParentACObject as ACClassInfoWithItems);
                    _DeleteItemsList.Add(element);
                    continue;
                }

                if (element.Items.Any())
                {
                    bool newFolder;
                    CurrentProgressInfo.TotalProgress.ProgressText = "Check or make folder " + element.ACIdentifier;
                    ITcSmTreeItem folder = CheckOrMakeFolder(parent, element, out newFolder);
                    if (folder == null)
                        continue;

                    ITcSmTreeItem existingPou = null;
                    if (newFolder)
                    {
                        existingPou = FindTreeItem(pouName, parent);
                        if (existingPou != null)
                            existingPou.Name = existingPou.Name + "TEMP";
                    }

                    CurrentProgressInfo.TotalProgress.ProgressText = "Check or make pou " + pouName;
                    ITcSmTreeItem pou = CheckOrMakePOU(folder, element, pouName);

                    CurrentProgressInfo.TotalProgress.ProgressCurrent += 1;

                    if (newFolder && existingPou != null)
                    {
                        CopyPou(existingPou, pou);
                        ITCSmTreeItemDeleteChild(parent, ITCAction(() => existingPou.Name));
                    }

                    SyncRecursive(folder, element, pouName);

                    if (CurrentACProject.ACProjectType == Global.ACProjectTypes.Application && element.ACIdentifier != _acClassInfoMovedName)
                    {
                        AddPouDeclarationAndImplementation(folder, pou, element);
                        _acClassInfoMovedName = "";
                    }
                }
                else
                {
                    CurrentProgressInfo.TotalProgress.ProgressText = "Check or make pou " + pouName;
                    ITcSmTreeItem childItem = CheckOrMakePOU(parent, element, pouName);
                    CurrentProgressInfo.TotalProgress.ProgressCurrent += 1;

                    if (childItem != null && CurrentACProject.ACProjectType == Global.ACProjectTypes.Application)
                        AddPouDeclarationAndImplementation(parent, childItem, element);
                }
            }
        }

        /// <summary>
        /// Synchronize projects recursive when one or more project items marked with tick.
        /// </summary>
        /// <param name="info">The current ACClassInfoWithItems (acClass).</param>
        /// <param name="parentName">The POU name.</param>
        /// <param name="parent">The parent TWINCAT element.</param>
        private void SyncRecursiveChecked(ACClassInfoWithItems info, string parentName, ITcSmTreeItem parent = null)
        {
            foreach (ACClassInfoWithItems item in info.Items)
            {
                string pouName = parentName + _TCdelimiter + item.ACIdentifier;
                if (item.IsChecked)
                {
                    CurrentProgressInfo.TotalProgress.ProgressCurrent++;
                    if ((Global.ChangeTypeEnum)item.IconState == Global.ChangeTypeEnum.Added)
                    {
                        if ((Global.ChangeTypeEnum)info.IconState == Global.ChangeTypeEnum.Changed || (Global.ChangeTypeEnum)info.IconState == Global.ChangeTypeEnum.None)
                        {
                            string path = GeneratePouPathToRootForAddedState(info);
                            ITcSmTreeItem treeItem = FindTreeItem(path, CurrentPOU);

                            if (treeItem == null && parent == null)
                            {
                                path = GeneratePouPathToRootForAddedState(info, false);
                                treeItem = FindTreeItem(path, CurrentPOU);
                            }

                            if (treeItem != null || parent != null)
                            {
                                if (parent != null && treeItem == null)
                                {
                                    treeItem = parent;
                                    parent = null;
                                }

                                bool newFolder;
                                if (item.Items.OfType<ACClassInfoWithItems>().Any(c => c.IsChecked))
                                {
                                    if (ITCAction(() => treeItem.ItemType) == (int)ItemType.Folder && ITCAction(() => treeItem.Name) == info.ACIdentifier)
                                    {
                                        CurrentProgressInfo.TotalProgress.ProgressText = "Check or make folder " + item.ACIdentifier;
                                        ITcSmTreeItem folder = CheckOrMakeFolder(treeItem, item, out newFolder);
                                        CurrentProgressInfo.TotalProgress.ProgressText = "Check or make pou " + pouName;
                                        ITcSmTreeItem pou = CheckOrMakePOU(folder, item, pouName);
                                        if (CurrentACProject.ACProjectType == Global.ACProjectTypes.Application)
                                            AddPouDeclarationAndImplementation(treeItem, pou, item);
                                    }
                                    else if (ITCAction(() => treeItem.ItemType) == (int)ItemType.Pou && ITCAction(() => (ITCAction(() => treeItem.Parent).Name)) == info.ACIdentifier)
                                    {
                                        CurrentProgressInfo.TotalProgress.ProgressText = "Check or make folder " + item.ACIdentifier;
                                        ITcSmTreeItem folder = CheckOrMakeFolder(ITCAction(() => treeItem.Parent), item, out newFolder);
                                        CurrentProgressInfo.TotalProgress.ProgressText = "Check or make pou " + pouName;
                                        ITcSmTreeItem pou = CheckOrMakePOU(folder, item, pouName);
                                        if (CurrentACProject.ACProjectType == Global.ACProjectTypes.Application)
                                            AddPouDeclarationAndImplementation(treeItem, pou, item);
                                    }
                                    else
                                    {
                                        string itemName = ITCAction(() => treeItem.Name);
                                        treeItem.Name = itemName + "TEMP";
                                        ITcSmTreeItem folder = CheckOrMakeFolder(ITCAction(() => treeItem.Parent), info, out newFolder);
                                        CurrentProgressInfo.TotalProgress.ProgressText = "Check or make pou " + pouName;
                                        ITcSmTreeItem pou = CheckOrMakePOU(folder, info, itemName);
                                        CopyPou(treeItem, pou);
                                        CurrentProgressInfo.TotalProgress.ProgressText = "Check or make folder " + item.ACIdentifier;
                                        ITcSmTreeItem addedFolder = CheckOrMakeFolder(folder, item, out newFolder);
                                        ITcSmTreeItem addedPou = CheckOrMakePOU(addedFolder, item, pouName);
                                        if (CurrentACProject.ACProjectType == Global.ACProjectTypes.Application)
                                            AddPouDeclarationAndImplementation(addedFolder, addedPou, item);
                                        parent = addedPou;
                                        ITCSmTreeItemDeleteChild(ITCAction(() => treeItem.Parent), ITCAction(() => treeItem.Name));
                                    }
                                }
                                else
                                {
                                    if (ITCAction(() => treeItem.ItemType) == (int)ItemType.Pou && ITCAction(() => (ITCAction(() => treeItem.Parent).Name)) == info.ACIdentifier)
                                    {
                                        CurrentProgressInfo.TotalProgress.ProgressText = "Check or make pou " + pouName;
                                        ITcSmTreeItem pou = CheckOrMakePOU(ITCAction(() => treeItem.Parent), item, pouName);
                                        if (CurrentACProject.ACProjectType == Global.ACProjectTypes.Application)
                                            AddPouDeclarationAndImplementation(treeItem, pou, item);
                                    }
                                    else if (ITCAction(() => treeItem.ItemType) == (int)ItemType.Folder && ITCAction(() => treeItem.Name) == info.ACIdentifier)
                                    {
                                        CurrentProgressInfo.TotalProgress.ProgressText = "Check or make pou " + pouName;
                                        ITcSmTreeItem pou = CheckOrMakePOU(treeItem, item, pouName);
                                        if (CurrentACProject.ACProjectType == Global.ACProjectTypes.Application)
                                            AddPouDeclarationAndImplementation(treeItem, pou, item);
                                    }
                                    else
                                    {
                                        string itemName = treeItem.Name;
                                        treeItem.Name = itemName + "TEMP";
                                        ITcSmTreeItem folder = CheckOrMakeFolder(ITCAction(() => treeItem.Parent), info, out newFolder);
                                        ITcSmTreeItem pou = CheckOrMakePOU(folder, info, itemName);
                                        CopyPou(treeItem, pou);
                                        CurrentProgressInfo.TotalProgress.ProgressText = "Check or make pou " + pouName;
                                        ITcSmTreeItem addedPou = CheckOrMakePOU(folder, item, pouName);
                                        if (CurrentACProject.ACProjectType == Global.ACProjectTypes.Application)
                                            AddPouDeclarationAndImplementation(folder, addedPou, item);
                                        ITCSmTreeItemDeleteChild(ITCAction(() => treeItem.Parent), ITCAction(() => treeItem.Name));
                                    }
                                }
                                item.IconState = Global.ChangeTypeEnum.None;
                            }
                        }
                    }
                    else if ((Global.ChangeTypeEnum)item.IconState == Global.ChangeTypeEnum.Removed)
                    {
                        string path = GeneratePouPathToRoot(item);
                        ITcSmTreeItem treeItem = FindTreeItem(path, CurrentPOU);
                        if (treeItem != null)
                        {
                            ITcSmTreeItem parentTreeItem = ITCAction(() => treeItem.Parent);
                            if (item.Items.Any())
                                parentTreeItem = ITCAction(() => parentTreeItem.Parent);

                            ResolveEdgesForDelete(treeItem);
                            DeleteFolderOrPou(item, parentTreeItem, pouName);
                            DeleteFromImplementationAndDeclaration(pouName, parentTreeItem);
                            CheckAndMoveAfterDelete(parentTreeItem, item.ParentACObject as ACClassInfoWithItems);
                            _DeleteItemsList.Add(item);
                            continue;
                        }
                    }
                    else if ((Global.ChangeTypeEnum)item.IconState == Global.ChangeTypeEnum.Changed)
                    {
                        UpdatePropertiesAndMethods(item);
                    }
                }
                SyncRecursiveChecked(item, pouName, parent);
            }
        }

        /// <summary>
        /// Create new PLC folder or check if PLC folder exist.
        /// </summary>
        /// <param name="tcItem">The parent PLC folder.</param>
        /// <param name="info">The current ACClassInfoWithItems (acClass).</param>
        /// <param name="newFolder">Flag, if new folder created.</param>
        /// <returns>Existing or new PLC folder.</returns>
        private ITcSmTreeItem CheckOrMakeFolder(ITcSmTreeItem tcItem, ACClassInfoWithItems info, out bool newFolder)
        {
            bool isFound = false;

            MessageFilter.Register();
            foreach (ITcSmTreeItem child in ITcSmTreeItemList(tcItem))
            {
                if (ITCAction(() => child.Name) == info.ACIdentifier)
                {
                    isFound = true;
                    break;
                }
            }

            if (isFound)
            {
                ITcSmTreeItem folder = tcItem.LookupChild(info.ACIdentifier);
                MessageFilter.Revoke();
                newFolder = false;
                return folder;
            }
            else
            {
                newFolder = true;
                return ITCSmTreeItemCreateChild(tcItem, info.ACIdentifier, ItemType.Folder, "", null);
            }
        }

        /// <summary>
        /// Create new POU or check if POU exist.
        /// </summary>
        /// <param name="tcItem">The parent PLC folder.</param>
        /// <param name="info">The current ACClassInfoWithItems (acClass).</param>
        /// <param name="pouName">The POU name.</param>
        /// <returns></returns>
        private ITcSmTreeItem CheckOrMakePOU(ITcSmTreeItem tcItem, ACClassInfoWithItems info, string pouName)
        {
            bool isFound = false;
            foreach (ITcSmTreeItem child in ITcSmTreeItemList(tcItem))
            {
                if (ITCAction(() => child.Name) == pouName)
                {
                    isFound = true;
                    break;
                }
            }

            if (isFound)
            {
                ITcSmTreeItem pou = tcItem.LookupChild(pouName);
                UpdatePropertiesAndMethods(info);
                return pou;
            }
            else
            {
                ITcSmTreeItem pou = ITCSmTreeItemCreateChild(tcItem, pouName, ItemType.Pou, "", ResolveVInfo(info));
                if (pou == null)
                    return null;
                AddDefaultPouAttributes(pou);
                AddProperty(pou, info.ValueT.ACClassProperty_ACClass);
                AddDefaultMethods(pou);
                AddMethods(pou, info.ValueT.ACClassMethod_ACClass);
                CreateMainDeclarationAndImplementation(pouName);
                return pou;
            }
        }

        /// <summary>
        /// Create parameters for POU depends on ACClass.
        /// </summary>
        /// <param name="info">The current ACClassInfoWithItems (acClass).</param>
        /// <returns>String array with POU parameters.</returns>
        private object ResolveVInfo(ACClassInfoWithItems info)
        {
            string[] vInfo;

            bool bExtends = false;
            bool bImplements = false;
            string extendsName = "";
            string implementName = "";

            if (info.ValueT.ACClass1_BasedOnACClass != null)
            {
                bExtends = true;
                if (CurrentACProject.ACProjectType == Global.ACProjectTypes.Application)
                {
                    extendsName = FindExtendsName(info.ValueT);
                }
                else
                    extendsName = info.ValueT.ObjectType.Name;

            }

            if (!string.IsNullOrEmpty(extendsName))
                bExtends = true;

            if (!string.IsNullOrEmpty(implementName))
                bImplements = true;

            if (bExtends && bImplements)
            {
                vInfo = new string[5];
            }
            else
            {
                if (bExtends || bImplements)
                {
                    vInfo = new string[3];
                }
                else
                {
                    vInfo = new string[1];
                }
            }
            vInfo[0] = "ST";
            if (bExtends && bImplements)
            {
                vInfo[1] = "Extends";
                vInfo[2] = extendsName;
                vInfo[3] = "Implements";
                vInfo[4] = implementName;
            }
            else
            {
                if (bExtends)
                {
                    vInfo[1] = "Extends";
                    vInfo[2] = extendsName;
                }
                else
                {
                    if (bImplements)
                    {
                        vInfo[1] = "Implements";
                        vInfo[2] = implementName;
                    }
                }
            }
            return vInfo;
        }

        /// <summary>
        /// Find extends name depends on acClass.
        /// </summary>
        /// <param name="acClass">The acClass.</param>
        /// <returns>Extends name.</returns>
        private string FindExtendsName(ACClass acClass)
        {
            acClass = acClass.ACClass1_BasedOnACClass;
            string name = acClass.ACIdentifier;
            bool isFind = false;

            while (!isFind)
            {
                if (acClass.ACClass1_ParentACClass == null)
                    break;
                if (acClass.ACClass1_ParentACClass.ACKind == Global.ACKinds.TACApplicationManager)
                {
                    isFind = true;
                    name = name.Insert(0, acClass.ACClass1_ParentACClass.ACIdentifier + "_I_");
                }
                else
                {
                    acClass = acClass.ACClass1_ParentACClass;
                    name = name.Insert(0, acClass.ACIdentifier + "_I_");
                }
            }

            return name;
        }

        /// <summary>
        /// Add declaration and implementation in PLC MAIN.
        /// </summary>
        /// <param name="main">The PLC MAIN.</param>
        /// <param name="childName">Name of child which will be added in MAIN declaration and implementation.</param>
        private void AddMainDeclarationAndImplementation(ITcSmTreeItem main, string childName)
        {
            ITcSmTreeItem vb = FindTreeItem("VB", CurrentPOU);
            if (vb == null)
            {
                string[] vInfo = new string[3];
                vInfo[0] = "ST";
                vInfo[1] = "Extends";
                vInfo[2] = "ACVariobatch";
                vb = ITCSmTreeItemCreateChild(CurrentPOU, "VB", ItemType.Pou, "", vInfo);

                if (!_mainDecl.Contains("_VB : VB(0);"))
                    _mainDecl = _mainDecl.Insert(0, "_VB : VB(0);" + System.Environment.NewLine);

                AddDefaultMethods(vb);
            }
    
            string mainDeclaration = ITCAction(() => main is ITcPlcDeclaration ? ((ITcPlcDeclaration)main).DeclarationText : null);
            string regionStart = "//VBRegionStart";

            if (mainDeclaration.Contains(regionStart) && mainDeclaration.Contains(_VBRegionEnd))
            {
                int startIndex = mainDeclaration.IndexOf(regionStart)+regionStart.Length;
                int endIndex = mainDeclaration.IndexOf(_VBRegionEnd);

                mainDeclaration = mainDeclaration.Remove(startIndex, endIndex - startIndex);
                mainDeclaration = mainDeclaration.Insert(startIndex, System.Environment.NewLine + _mainDecl + System.Environment.NewLine);
                mainDeclaration = mainDeclaration.Insert(startIndex + (System.Environment.NewLine + _mainDecl + System.Environment.NewLine).Length, 
                                                         System.Environment.NewLine + _mainEdgeDecl + System.Environment.NewLine);
            }
            else
            {
                mainDeclaration = mainDeclaration.Insert(mainDeclaration.IndexOf("VAR") + 3, System.Environment.NewLine +
                                                        _VBRegionStart + System.Environment.NewLine + 
                                                        _mainDecl + System.Environment.NewLine + 
                                                        _mainEdgeDecl + System.Environment.NewLine + 
                                                        _VBRegionEnd + System.Environment.NewLine);
            }

            ITCPlcDeclarationTextSet(main, mainDeclaration);

            string mainImpl = ITCAction(() => main is ITcPlcImplementation ? ((ITcPlcImplementation)main).ImplementationText : null);
            string mainImplementation = _VBRegionStart + System.Environment.NewLine + "IF Automation_components_gip.GVL.gInstanceIDCount = 0 THEN" + System.Environment.NewLine +
                        _4spaces + "_VB.FB_childinit();" + System.Environment.NewLine +
                        _4spaces + "_VB.FB_postinit(_VB);" + System.Environment.NewLine + "END_IF" + System.Environment.NewLine + System.Environment.NewLine +
                        "_VB.RunMain();" + System.Environment.NewLine + _VBRegionEnd;

            if (string.IsNullOrEmpty(mainImpl))
                ITCPlcImplementationTextSet(main, mainImplementation);

            else if (!mainImpl.Contains(mainImplementation))
            {
                using (StringReader reader = new StringReader(mainImpl))
                {
                    StringBuilder sb = new StringBuilder();
                    string line = "";
                    do
                    {
                        line = reader.ReadLine();
                        if (line != null)
                        {
                            if (!mainImpl.Contains(_VBRegionStart) && !mainImpl.Contains(_VBRegionEnd))
                            {
                                sb.AppendLine(mainImplementation);
                                sb.AppendLine(line);
                            }
                            else if (line.Equals(_VBRegionStart) && !mainImpl.Contains("IF Automation_components_gip.GVL.gInstanceIDCount = 0 THEN"))
                            {
                                sb.AppendLine(line);
                                sb.AppendLine("IF Automation_components_gip.GVL.gInstanceIDCount = 0 THEN");
                            }
                            else if (line.Equals("IF Automation_components_gip.GVL.gInstanceIDCount = 0 THEN") && !mainImpl.Contains(_4spaces + "_VB.FB_childinit();"))
                            {
                                sb.AppendLine(line);
                                sb.AppendLine(_4spaces + "_VB.FB_childinit();");
                            }
                            else if (line.Equals(_4spaces + "_VB.FB_childinit();") && !mainImpl.Contains(_4spaces + "_VB.FB_postinit();"))
                            {
                                sb.AppendLine(line);
                                sb.AppendLine(_4spaces + "_VB.FB_postinit();");
                            }
                            else if (line.Equals(_4spaces + "_VB.FB_postinit();") && !mainImpl.Contains("END_IF"))
                            {
                                sb.AppendLine(line);
                                sb.AppendLine("END_IF");
                            }
                            else if (line.Equals(_4spaces + "END_IF") && !mainImpl.Contains("_VB.RunMain();"))
                            {
                                sb.AppendLine(line);
                                sb.AppendLine(System.Environment.NewLine + "_VB.RunMain();");
                            }
                            else
                                sb.AppendLine(line);
                        }
                    }
                    while (line != null);
                }
            }
            
            AddVBDeclarationAndImplementation(vb, childName);
        }

        private void RemoveDeletedItemsFromMain(ITcSmTreeItem main)
        {
            foreach(var edgeTuple in _edgeDeleteCache)
            {
                int edgeIndex = _mainEdgeDecl.IndexOf(edgeTuple.Item2);
                if (edgeIndex != -1)
                {
                    int endIndex = _mainEdgeDecl.IndexOf(';', edgeIndex)+1;
                    string edge = _mainEdgeDecl.Substring(edgeIndex, endIndex - edgeIndex);

                    var edgeParts = edge.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

                    if(edgeParts[0].Contains(edgeTuple.Item1))
                    {
                        string pointPart = edgeParts[1].Trim();
                        string pouName = pointPart.Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
                        ITcSmTreeItem pou = FindPouFromRoot(pouName.Remove(0,1));
                        if(pou != null)
                            DeleteEdgeFromPouDeclarationAndImplementation(pou, edgeTuple.Item2);
                    }
                    else
                    {
                        string pointPart = edgeParts[0].Split(new char[] { '(' }, StringSplitOptions.RemoveEmptyEntries).LastOrDefault();
                        string pouName = pointPart.Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
                        ITcSmTreeItem pou = FindPouFromRoot(pouName.Remove(0,1));
                        if(pou != null)
                            DeleteEdgeFromPouDeclarationAndImplementation(pou, edgeTuple.Item2);
                    }

                    _mainEdgeDecl = _mainEdgeDecl.Replace(edge, "");
                }
            }

            _mainEdgeDecl = _mainEdgeDecl.Replace(System.Environment.NewLine + System.Environment.NewLine, System.Environment.NewLine);

            foreach (string deletedPou in _pouDeleteCache)
            {
                int startIndex = _mainDecl.IndexOf("_" + deletedPou + " :");
                if (startIndex == -1)
                    startIndex = _mainDecl.IndexOf(_4spaces + "_" + deletedPou + " :");

                if(startIndex != -1)
                {
                    int endIndex = _mainDecl.IndexOf(';', startIndex) +1;
                    _mainDecl = _mainDecl.Remove(startIndex, endIndex - startIndex);
                }
            }
            _mainDecl = _mainDecl.Replace(System.Environment.NewLine + System.Environment.NewLine, System.Environment.NewLine);
        }

        /// <summary>
        /// Add declaration and implementation to VB pou in TwinCAT project.
        /// </summary>
        /// <param name="vb">The VB pou.</param>
        /// <param name="childName">Name of child, which will be added to VB pou.</param>
        private void AddVBDeclarationAndImplementation(ITcSmTreeItem vb, string childName)
        {
            string declaration = ITCAction(() => vb is ITcPlcDeclaration ? ((ITcPlcDeclaration)vb).DeclarationText : null);
            bool initialDecl = !declaration.Contains(_VBRegionStart) && !declaration.Contains(_VBRegionEnd);

            using (StringReader reader = new StringReader(declaration))
            {
                StringBuilder sb = new StringBuilder();
                string line = "";
                do
                {
                    line = reader.ReadLine();
                    if (line != null)
                    {
                        if (initialDecl && line.Equals("VAR_INPUT"))
                        {
                            sb.AppendLine(line);
                            sb.AppendLine(VBRegionStart(_4spaces));
                            sb.AppendLine(_8spaces + "_" + childName + " :" + _ReferenceTo + childName + ";");
                            sb.AppendLine(_4spaces + _VBRegionEnd);
                        }
                        else if (line.Equals(_4spaces + _VBRegionEnd) && !declaration.Contains(_8spaces + "_" + childName + " :" + _ReferenceTo + childName + ";"))
                        {
                            sb.AppendLine(_8spaces + "_" + childName + " :" + _ReferenceTo + childName + ";");
                            sb.AppendLine(line);
                        }
                        else
                            sb.AppendLine(line);
                    }
                }
                while (line != null);
                ITCPlcDeclarationTextSet(vb, sb.ToString());
            }



            ITcSmTreeItem fbChildInit = FindTreeItem("FB_childinit", vb);
            if (fbChildInit == null)
            {
                string[] vInfo = new string[4];
                vInfo[0] = "ST";
                vInfo[1] = "";
                vInfo[2] = "PUBLIC";
                vInfo[3] = "";
                fbChildInit = ITCSmTreeItemCreateChild(vb, "FB_childinit", ItemType.Method, "", vInfo);
            }


            string implementation = ITCAction(() => fbChildInit is ITcPlcImplementation ? ((ITcPlcImplementation)fbChildInit).ImplementationText : null);

            if (string.IsNullOrEmpty(implementation))
            {
                implementation = _VBRegionStart + System.Environment.NewLine + _4spaces + "_"+childName + " REF= MAIN._" + childName + ";"+ 
                                                  System.Environment.NewLine + _4spaces + "AddChild(_" + childName + ");" + 
                                                  System.Environment.NewLine + _4spaces + "SUPER^.FB_childinit();" + System.Environment.NewLine +
                                 _VBRegionEnd;
                ITCPlcImplementationTextSet(fbChildInit, implementation);
            }
            else
            {
                using (StringReader reader = new StringReader(implementation))
                {
                    StringBuilder sb = new StringBuilder();
                    string line = "";
                    do
                    {
                        line = reader.ReadLine();
                        if (line != null)
                        {
                            if (!implementation.Contains(_VBRegionStart) && !implementation.Contains(_VBRegionEnd))
                            {
                                sb.AppendLine(_VBRegionStart);
                                sb.AppendLine(_4spaces + "_"+childName + " REF= MAIN._" + childName + ";");
                                sb.AppendLine(_4spaces + "AddChild(_" + childName + ");");
                                sb.AppendLine(_4spaces + "SUPER^.FB_childinit();");
                                sb.AppendLine(_VBRegionEnd);
                            }
                            else if (line.Equals("SUPER^.FB_childinit();") && !implementation.Contains(_4spaces + "AddChild(_" + childName + ");"))
                            {
                                sb.AppendLine(_4spaces + "_" + childName + " REF= MAIN._" + childName+ ";");
                                sb.AppendLine(_4spaces + "AddChild(_" + childName + ");");
                                sb.AppendLine(line);
                            }
                            else
                                sb.AppendLine(line);
                        }
                    }
                    while (line != null);
                    ITCPlcImplementationTextSet(fbChildInit, sb.ToString());
                }
            }
        }

        /// <summary>
        /// Add default pou attributes (no explicit call attribute)
        /// </summary>
        /// <param name="pou">The pou.</param>
        private void AddDefaultPouAttributes(ITcSmTreeItem pou)
        {
            string declaration = ITCAction(() => pou is ITcPlcDeclaration ? ((ITcPlcDeclaration)pou).DeclarationText : null);
            if (declaration.Contains("{attribute 'no_explicit_call' := 'Pou directly call is disabled.'}"))
                return;
            declaration = declaration.Insert(0, "{attribute 'no_explicit_call' := 'Pou directly call is disabled.'}" + System.Environment.NewLine);
            ITCPlcDeclarationTextSet(pou, declaration);
        }

        /// <summary>
        /// Add VBAutoGenerated region.
        /// </summary>
        /// <param name="pou">The POU.</param>
        private void AddVBAutoGeneratedRegion(ITcSmTreeItem pou)
        {
            string decl = ITCAction(() => pou is ITcPlcDeclaration ? ((ITcPlcDeclaration)pou).DeclarationText : null);
            using (StringReader reader = new StringReader(decl))
            {
                StringBuilder sb = new StringBuilder();
                string line = string.Empty;
                do
                {
                    line = reader.ReadLine();
                    if (line != null)
                    {
                        sb.AppendLine(line);
                        if (line.Equals("VAR_OUTPUT"))
                        {
                            sb.AppendLine(VBRegionStart(_4spaces));
                            sb.AppendLine(_4spaces + _VBRegionEnd);
                        }
                    }
                }
                while (line != null);
                ITCPlcDeclarationTextSet(pou, sb.ToString());
            }
        }

        /// <summary>
        /// Add POU declaration and implementation. 
        /// </summary>
        /// <param name="parentPou">The parent POU.</param>
        /// <param name="childPou">The child POU.</param>
        /// <param name="info">The ACClassInfoWithItems (acClass).</param>
        private void AddPouDeclarationAndImplementation(ITcSmTreeItem parentPou, ITcSmTreeItem childPou, ACClassInfoWithItems info)
        {
            ITcSmTreeItem parentCorrectPou = parentPou;
            ITcSmTreeItem childCorrectPou = childPou;

            if (ITCAction(() => parentPou.ItemType) == (int)ItemType.Folder)
            {
                foreach (ITcSmTreeItem item in ITcSmTreeItemList(parentPou))
                    if (ITCAction(() => item.Name).Split(delimiter, StringSplitOptions.RemoveEmptyEntries).LastOrDefault() == ITCAction(() => parentPou.Name) && ITCAction(() => item.ItemType) == (int)ItemType.Pou)
                    {
                        parentCorrectPou = item;
                        break;
                    }
            }

            if (ITCAction(() => childPou.ItemType) == (int)ItemType.Folder)
            {
                foreach (ITcSmTreeItem childItem in ITcSmTreeItemList(childPou))
                    if (ITCAction(() => childItem.Name).Split(delimiter, StringSplitOptions.RemoveEmptyEntries).LastOrDefault() == ITCAction(() => childPou.Name) && ITCAction(() => childItem.ItemType) == (int)ItemType.Pou)
                    {
                        childCorrectPou = childItem;
                        break;
                    }
            }

            if (ITCAction(() => parentCorrectPou.Name) == ITCAction(() => childCorrectPou.Name))
            {
                ITcSmTreeItem parent = ITCAction(() => parentPou.Parent);
                foreach (ITcSmTreeItem item in ITcSmTreeItemList(parent))
                    if (ITCAction(() => item.Name).Split(delimiter, StringSplitOptions.RemoveEmptyEntries).LastOrDefault() == ITCAction(() => parent.Name) && ITCAction(() => item.ItemType) == (int)ItemType.Pou)
                    {
                        parentCorrectPou = item;
                        break;
                    }
            }

            string declaration = ITCAction(() => parentCorrectPou is ITcPlcDeclaration ? ((ITcPlcDeclaration)parentCorrectPou).DeclarationText : null);
            string createdDeclaration;

            if (!declaration.Contains(_VBRegionStart) && !declaration.Contains(_VBRegionEnd))
                createdDeclaration = CreateAddChildDeclaration(parentCorrectPou, childCorrectPou, true);

            else
                createdDeclaration = CreateAddChildDeclaration(parentCorrectPou, childCorrectPou);

            ITCPlcDeclarationTextSet(parentCorrectPou, createdDeclaration);
        }

        /// <summary>
        /// Create add child declaration.
        /// </summary>
        /// <param name="parentPou">The parent POU.</param>
        /// <param name="childPou">The child POU.</param>
        /// <param name="initialDeclaration">The initial declaration.s</param>
        /// <returns>Created declaration.</returns>
        private string CreateAddChildDeclaration(ITcSmTreeItem parentPou, ITcSmTreeItem childPou, bool initialDeclaration = false)
        {
            string createdDecl;
            string declaration = ITCAction(() => parentPou is ITcPlcDeclaration ? ((ITcPlcDeclaration)parentPou).DeclarationText : null);
            using (StringReader reader = new StringReader(declaration))
            {
                StringBuilder sb = new StringBuilder();
                string line = string.Empty;
                do
                {
                    line = reader.ReadLine();
                    if (line != null)
                    {
                        sb.AppendLine(line);
                        if (initialDeclaration && line.Equals("VAR_INPUT"))
                        {
                            sb.AppendLine(VBRegionStart(_4spaces));
                            string childName = _8spaces + "_" + ITCAction(() => childPou.Name).Split(delimiter, StringSplitOptions.RemoveEmptyEntries).LastOrDefault() + " :" + _ReferenceTo + ITCAction(() => childPou.Name)+";";
                            sb.AppendLine(childName);
                            AddChildFBInitImplementation(ITCAction(() => childPou.Name), parentPou);
                            sb.AppendLine(_4spaces + _VBRegionEnd);
                        }
                        else if (line == _4spaces + "//VBRegionStart")
                        {
                            string childName = _8spaces + "_" + ITCAction(() => childPou.Name).Split(delimiter, StringSplitOptions.RemoveEmptyEntries).LastOrDefault() + " :" + _ReferenceTo + ITCAction(() => childPou.Name)+";";
                            if (!declaration.Contains(childName))
                                sb.AppendLine(childName);
                            AddChildFBInitImplementation(ITCAction(() => childPou.Name), parentPou);
                        }
                    }
                }
                while (line != null);

                createdDecl = sb.ToString();
            }
            return createdDecl;
        }

        /// <summary>
        /// Create and add AddChild POU implementation.
        /// </summary>
        /// <param name="childName">The child name.</param>
        /// <param name="pou">The POU.</param>
        private void AddChildFBInitImplementation(string childFullName, ITcSmTreeItem pou)
        {
            string childName = childFullName.Split(delimiter, StringSplitOptions.RemoveEmptyEntries).LastOrDefault();

            List<ITcSmTreeItem> listChilds = ITcSmTreeItemList(pou);
            ITcSmTreeItem postInit = listChilds.FirstOrDefault(c => ITCAction(() => c.Name) == "FB_childinit" && ITCAction(() => c.ItemType) == (int)ItemType.Method);

            if (postInit == null)
            {
                string[] vInfo = new string[4];
                vInfo[0] = "ST";
                vInfo[1] = "";
                vInfo[2] = "PUBLIC";
                vInfo[3] = "";
                postInit = ITCSmTreeItemCreateChild(pou, "FB_childinit", ItemType.Method, "", vInfo);
                string decl = ITCAction(() => postInit is ITcPlcDeclaration ? ((ITcPlcDeclaration)postInit).DeclarationText : null);
                decl = decl + System.Environment.NewLine + "VAR_INPUT" + System.Environment.NewLine + "END_VAR";
                ITCPlcDeclarationTextSet(postInit, decl);
            }

            string implementation = ITCAction(() => postInit is ITcPlcImplementation ? ((ITcPlcImplementation)postInit).ImplementationText : null);
            string createdImplementation;
            if (string.IsNullOrEmpty(implementation))
            {
                createdImplementation = _VBRegionStart + System.Environment.NewLine +
                                        _4spaces + "_" + childName + " REF= MAIN._" + childFullName + ";" + System.Environment.NewLine + 
                                        _4spaces + "AddChild(_" + childName + ");" + System.Environment.NewLine +
                                        _4spaces + "SUPER^.FB_childinit();" + System.Environment.NewLine +
                                        _VBRegionEnd;
            }
            else
            {
                using (StringReader reader = new StringReader(implementation))
                {
                    StringBuilder sb = new StringBuilder();
                    string line = string.Empty;
                    do
                    {
                        line = reader.ReadLine();
                        if (line != null)
                        {
                            sb.AppendLine(line);
                            if (line == "//VBRegionStart" && !implementation.Contains("_" + childName + " REF= MAIN._" + childFullName + ";"))
                            {
                                sb.AppendLine(_4spaces + "_" + childName + " REF= MAIN._" + childFullName + ";");
                                sb.AppendLine(_4spaces + "AddChild(_" + childName + ");");
                            }
                        }
                    }
                    while (line != null);
                    createdImplementation = sb.ToString();
                }
            }
            ITCPlcImplementationTextSet(postInit, createdImplementation);
                    
        }

        /// <summary>
        /// Create connections between components. 
        /// </summary>
        /// <param name="info">The ACClassInfoWithItems (acClass).</param>
        /// <param name="parentName">The parent name.</param>
        /// <param name="onlyInfoChecked">If true, crates connections only for items which marked with tick.</param>
        private void CreateComponentConnection(ACClassInfoWithItems info, string parentName, bool onlyInfoChecked = false)
        {
            foreach (ACClassInfoWithItems item in info.Items)
            {
                string pouName = parentName + _TCdelimiter + item.ACIdentifier;
                if ((!onlyInfoChecked && item.ValueT != null
                                     && item.ValueT.ACClassPropertyRelation_SourceACClass.Any(c => c.ConnectionTypeIndex == (short)Global.ConnectionTypes.ConnectionPhysical))
                                     || (onlyInfoChecked && item.IsChecked && item.ValueT != null
                                     && item.ValueT.ACClassPropertyRelation_SourceACClass.Any(c => c.ConnectionTypeIndex == (short)Global.ConnectionTypes.ConnectionPhysical)))
                {
                    foreach (var connection in item.ValueT.ACClassPropertyRelation_SourceACClass.Where(c => c.ConnectionTypeIndex == (short)Global.ConnectionTypes.ConnectionPhysical
                                                                                                            || c.ConnectionTypeIndex == (short)Global.ConnectionTypes.LogicalBridge))
                    {
                        string targetName = FindPouName(connection.TargetACClass);
                        string targetNameDecl = CreatePathToRootForTargetName(targetName);
                        ITcSmTreeItem target = FindPouFromRoot(targetName);

                        string sourcePouName = FindPouName(connection.SourceACClass);
                        ITcSmTreeItem sourceItem = FindPouFromRoot(sourcePouName);

                        if (target != null && sourceItem != null)
                        {
                            string targetProperty;
                            string edge = AddEdgeDeclaration(sourceItem, targetName, targetNameDecl, connection, out targetProperty);
                            if (!string.IsNullOrEmpty(edge))
                            {
                                AddEdgeInfoOnTarget(target, edge, targetProperty);
                            }
                        }
                        else
                        {
                            string errorEdge = connection.SourceACClass.ACIdentifier + " => " + connection.TargetACClass.ACIdentifier;

                            if (target == null && sourceItem != null)
                                errorEdge = errorEdge + " (Can't find target POU.)";
                            else if (sourceItem == null && target != null)
                                errorEdge = errorEdge + " (Can't find source POU.)";
                            else
                                errorEdge = errorEdge + " (Can't find source and target POU.)";

                            _NotAddedEdgesList.Add(errorEdge);
                        }
                    }
                }
                CreateComponentConnection(item, pouName);
            }
        }

        //private string CreatePathToRootForTargetName(string targetName)
        //{
        //    string generatedName = targetName;
        //    string[] parts = targetName.Split(delimiter, StringSplitOptions.RemoveEmptyEntries);

        //    for (int i = parts.Count()-2; i >= 0; i--)
        //    {
        //        string input = parts[i];
        //        for(int j = i-1; j >= 0 && j != i; j--)
        //        {
        //            input = input.Insert(0, parts[j] + _TCdelimiter);
        //        }
        //        generatedName = generatedName.Insert(0, input + ".");
        //    }
        //    generatedName = generatedName.Insert(0, "MAIN.");
        //    return generatedName;
        //}

        /// <summary>
        /// Generate path to root for targetName.
        /// </summary>
        /// <param name="targetName">The target name.</param>
        /// <returns></returns>
        private string CreatePathToRootForTargetName(string targetName)
        {
            string generatedName = "";
            string[] parts = targetName.Split(delimiter, StringSplitOptions.RemoveEmptyEntries);

            foreach (string part in parts)
            {
                generatedName += "._" + part;
            }
            generatedName = generatedName.Insert(0, "MAIN._VB");
            return generatedName;
        }

        /// <summary>
        /// Create and add edge declaration.
        /// </summary>
        /// <param name="sourceItem">The source POU.</param>
        /// <param name="targetName">The target name.</param>
        /// <returns>Created edge name.</returns>
        private string AddEdgeDeclaration(ITcSmTreeItem sourceItem, string targetName, string targetNameToMain, ACClassPropertyRelation connection, out string targetProperty)
        {
            string connectionType = connection.ConnectionType.ToString();
            string currentEdge = "_Edge0001";
            string sourceProp = connection.SourceACClassProperty.ACIdentifier;
            string targetProp = connection.TargetACClassProperty.ACIdentifier;
            targetProperty = targetProp;

            string instanceName = ITCAction(() => sourceItem.Name);
            string edgeInstance = string.Format("PAEdge(_{0}._{1}, _{2}._{3}, ConnectionTypesEnum.{4})", instanceName, sourceProp, targetName, targetProp, connectionType);

            if (string.IsNullOrEmpty(_mainEdgeDecl))
            {
                _lastEdgeNo = 1;
                _mainEdgeDecl = string.Format("{0}{1} : {2}", _4spaces, currentEdge, edgeInstance+";");
            }
            else if(_mainEdgeDecl.Contains(edgeInstance))
            {
                string instanceLine = _mainEdgeDecl.Split(new char[] { ';'}, StringSplitOptions.None).FirstOrDefault(c => c.Contains(edgeInstance));
                currentEdge = instanceLine.Split(new char[] {':'}).FirstOrDefault().Replace("_Edge", "").Trim();
            }
            else
            {
                _lastEdgeNo++;
                currentEdge = string.Format("_Edge{0}", _lastEdgeNo.ToString("000#"));
                _mainEdgeDecl += System.Environment.NewLine + string.Format("{0}{1} : {2}", _4spaces, currentEdge, edgeInstance+";");
            }

            string declaration = ITCAction(() => sourceItem is ITcPlcDeclaration ? ((ITcPlcDeclaration)sourceItem).DeclarationText : null);

            bool initialDeclaration = false;
            if (!declaration.Contains(_VBRegionStart) && !declaration.Contains(_VBRegionEnd))
                initialDeclaration = true;

            using (StringReader reader = new StringReader(declaration))
            {
                StringBuilder sb = new StringBuilder();
                string line = string.Empty;
                do
                {
                    line = reader.ReadLine();
                    if (line != null)
                    {
                        if (initialDeclaration && line.Equals("VAR_INPUT"))
                        {
                            sb.AppendLine(line);
                            sb.AppendLine(VBRegionStart(_4spaces));
                            string edge = string.Format("{0}{1} : REFERENCE TO PAEdge;",_8spaces, currentEdge);
                            sb.AppendLine(edge);
                            sb.AppendLine(_4spaces + _VBRegionEnd);
                            AddEdgeFBPostInitImplementation(currentEdge, sourceItem, sourceProp);
                        }
                        else if (line == _4spaces + _VBRegionEnd)
                        {
                            //string partEdge = "PAEdge(" + "_" + sourceProp + ", " + targetName + "." + "_" + targetProp + ", ConnectionTypesEnum." + connectionType + ");";
                            if (!declaration.Contains(currentEdge))
                            {
                                string edge = string.Format("{0}{1} : REFERENCE TO PAEdge;", _8spaces, currentEdge);
                                sb.AppendLine(edge);
                                AddEdgeFBPostInitImplementation(currentEdge, sourceItem, sourceProp);
                            }
                            sb.AppendLine(line);
                        }
                        else
                            sb.AppendLine(line);
                    }
                }
                while (line != null);

                ITCPlcDeclarationTextSet(sourceItem, sb.ToString());
                return currentEdge;
            }
        }

        /// <summary>
        /// Create and add edge implementation on POU FB_init.
        /// </summary>
        /// <param name="edgeName">The edge name.</param>
        /// <param name="targetName">The target name.</param>
        /// <param name="pou">The source POU.</param>
        private void AddEdgeFBPostInitImplementation(string edgeName, ITcSmTreeItem pou, string propName)
        {
            List<ITcSmTreeItem> listChilds = ITcSmTreeItemList(pou);
            ITcSmTreeItem postInit = listChilds.FirstOrDefault(c => ITCAction(() => c.Name) == "FB_postinit" && ITCAction(() => c.ItemType) == (int)ItemType.Method);
            bool callPostInit = false;

            if (postInit == null)
            {
                string[] vInfo = new string[4];
                vInfo[0] = "ST";
                vInfo[1] = "";
                vInfo[2] = "PUBLIC";
                vInfo[3] = "";
                postInit = ITCSmTreeItemCreateChild(pou, "FB_postinit", ItemType.Method, "", vInfo);
                string decl = ITCAction(() => postInit is ITcPlcDeclaration ? ((ITcPlcDeclaration)postInit).DeclarationText : null);
                decl = decl + System.Environment.NewLine + "VAR_INPUT" + System.Environment.NewLine + _4spaces + "root : IACVariobatch;" + System.Environment.NewLine + "END_VAR";
                ITCPlcDeclarationTextSet(postInit, decl);
            }

            if (postInit == null)
                return;

            string implementation = ITCAction(() => postInit is ITcPlcImplementation ? ((ITcPlcImplementation)postInit).ImplementationText : null);
            string createdImplementation;
            if (string.IsNullOrEmpty(implementation))
            {
                createdImplementation = _VBRegionStart + System.Environment.NewLine +
                                        _4spaces + "IF NOT(ACInitState = ACInitStateEnum.Unchanged) THEN"
                                        + System.Environment.NewLine +
                                        _8spaces + edgeName + " REF= MAIN."+edgeName+ ";" + System.Environment.NewLine + 
                                        _8spaces + propName + ".AddEdge(" + edgeName + ");"
                                        + System.Environment.NewLine +
                                        _4spaces + "END_IF"
                                        + System.Environment.NewLine + _VBRegionEnd
                                        + System.Environment.NewLine + System.Environment.NewLine +
                                        _VBRegionStart + System.Environment.NewLine +
                                        _4spaces + "SUPER^.FB_postinit(root);"
                                        + System.Environment.NewLine + _VBRegionEnd;
            }
            else
            {
                if (!implementation.Contains(_VBRegionEnd))
                {
                    implementation += System.Environment.NewLine + _VBRegionStart + System.Environment.NewLine +
                                     _4spaces + "IF NOT(ACInitState = ACInitStateEnum.Unchanged) THEN" +  System.Environment.NewLine +
                                     _4spaces + "END_IF" + System.Environment.NewLine +
                                     _VBRegionEnd;
                }

                if (!implementation.Contains(_4spaces + "IF NOT(ACInitState = ACInitStateEnum.Unchanged) THEN"))
                {
                    int indexOfVBRegEnd = implementation.IndexOf(_VBRegionEnd);

                    implementation = implementation.Insert(indexOfVBRegEnd, System.Environment.NewLine +
                         _4spaces + "IF NOT(ACInitState = ACInitStateEnum.Unchanged) THEN" + System.Environment.NewLine +
                         _4spaces + "END_IF" + System.Environment.NewLine); 
                }

                using (StringReader reader = new StringReader(implementation))
                {
                    StringBuilder sb = new StringBuilder();
                    string line = string.Empty;
                    do
                    {
                        line = reader.ReadLine();
                        if (line != null)
                        {
                            if (line == _4spaces + "END_IF" && !implementation.Contains(edgeName) && !callPostInit)
                            {
                                sb.AppendLine(_8spaces + edgeName + " REF= MAIN." + edgeName + ";");
                                sb.AppendLine(_8spaces + propName + ".AddEdge(" + edgeName + ");");
                                callPostInit = true;
                            }
                            sb.AppendLine(line);
                        }
                    }
                    while (line != null);
                    createdImplementation = sb.ToString();
                }
            }
            ITCPlcImplementationTextSet(postInit, createdImplementation);
        }

        /// <summary>
        /// Add edge info on target.
        /// </summary>
        /// <param name="target">The target POU.</param>
        /// <param name="edgeInfo">The edge info.</param>
        private void AddEdgeInfoOnTarget(ITcSmTreeItem target, string edgeInfo, string targetProperty)
        {
            string edgeInfo1 = edgeInfo + " : REFERENCE TO PAEdge;";

            string declaration = ITCAction(() => target is ITcPlcDeclaration ? ((ITcPlcDeclaration)target).DeclarationText : null);
            bool initialDeclaration = false;
            if (!declaration.Contains(_VBRegionStart) && !declaration.Contains(_VBRegionEnd))
                initialDeclaration = true;

            if (!initialDeclaration && declaration.Contains(edgeInfo))
                return;

            using (StringReader reader = new StringReader(declaration))
            {
                StringBuilder sb = new StringBuilder();
                string line = string.Empty;
                do
                {
                    line = reader.ReadLine();
                    if (line != null)
                    {
                        if (initialDeclaration && line.Equals("VAR"))
                        {
                            sb.AppendLine(line);
                            sb.AppendLine(VBRegionStart(_4spaces));
                            sb.AppendLine(_8spaces  + edgeInfo1);
                            sb.AppendLine(_4spaces + _VBRegionEnd);
                        }
                        else if (line == _4spaces + _VBRegionEnd)
                        {
                            sb.AppendLine(_8spaces + edgeInfo1);
                            sb.AppendLine(line);
                        }
                        else
                            sb.AppendLine(line);
                    }
                }
                while (line != null);

                ITCPlcDeclarationTextSet(target, sb.ToString());

                AddEdgeFBPostInitImplementation(edgeInfo, target, targetProperty);
            }
        }

        /// <summary>
        /// Add property to POU.
        /// </summary>
        /// <param name="pou">The POU.</param>
        /// <param name="acClass">The acClass.</param>
        private void AddProperty(ITcSmTreeItem pou, IEnumerable<ACClassProperty> properties)
        {
            foreach (var property in properties.Where(c => c.IsRPCEnabled))
            {
                dynamic vInfo = new string[3];
                vInfo[0] = "ST";
                vInfo[1] = TranslateType(property.ObjectType);
                vInfo[2] = "PUBLIC";
                ITcSmTreeItem prop = ITCSmTreeItemCreateChild(pou, property.ACIdentifier, ItemType.Property, "", (object)vInfo);

                AddPropertySet(prop);
                AddPropertyGet(prop);
            }
        }

        /// <summary>
        /// Add property setter.
        /// </summary>
        /// <param name="prop">The property.</param>
        private void AddPropertySet(ITcSmTreeItem prop)
        {
            dynamic vInfo = new string[3];
            vInfo[0] = "ST";
            vInfo[1] = "PUBLIC";
            vInfo[2] = @"<ST><![CDATA[(* ST PropSet *)]]></ST>";

            prop.CreateChild("", (int)ItemType.PropSet, "", (object)vInfo);
        }

        /// <summary>
        /// Add property getter.
        /// </summary>
        /// <param name="prop">The property.</param>
        private void AddPropertyGet(ITcSmTreeItem prop)
        {
            dynamic vInfo = new string[3];
            vInfo[0] = "ST";
            vInfo[1] = "PUBLIC";
            vInfo[2] = @"<ST><![CDATA[(* ST PropGet *)]]></ST>";

            prop.CreateChild("", (int)ItemType.PropGet, "", (object)vInfo);
        }

        /// <summary>
        /// Update TwinCAT properties and methods from acClass.
        /// </summary>
        /// <param name="info">The acClass info.</param>
        private void UpdatePropertiesAndMethods(ACClassInfoWithItems info)
        {
            if (info.ValueT == null)
                return;

            string path = GeneratePouPathToRoot(info);
            ITcSmTreeItem treeItem = FindTreeItem(path, CurrentPOU);
            if (treeItem == null)
                return;

            if (ITCAction(() => treeItem.ItemType) == (int)ItemType.Folder)
                treeItem = FindTreeItem(path, treeItem);

            int propCount = 0;
            List<ACClassProperty> propSync = new List<ACClassProperty>();
            int methodCount = 0;
            List<ACClassMethod> methodSync = new List<ACClassMethod>();

            foreach (ITcSmTreeItem item in ITcSmTreeItemList(treeItem))
            {
                string itemName = ITCAction(() => item.Name);
                if (ITCAction(() => item.ItemType) == (int)ItemType.Property && !CheckIsItemUserDefined(itemName))
                {
                    var prop = info.ValueT.ACClassProperty_ACClass.FirstOrDefault(c => c.IsRPCEnabled && c.ACIdentifier == itemName);
                    if (prop == null)
                    {
                        ITCSmTreeItemDeleteChild(treeItem, itemName);
                        continue;
                    }
                    propSync.Add(prop);
                    propCount++;
                }
                else if (ITCAction(() => item.ItemType) == (int)ItemType.Method && itemName != "FB_init" && itemName != "FB_reinit" && itemName != "FB_exit"
                                                               && itemName != "FB_postinit" && itemName != "OnMainEnter" && itemName != "OnMainExit" && itemName != "FB_childinit"
                                                               && !CheckIsItemUserDefined(itemName))
                {
                    var method = info.ValueT.ACClassMethod_ACClass.FirstOrDefault(c => c.IsRPCEnabled && c.ACIdentifier == itemName);
                    if (method == null)
                    {
                        ITCSmTreeItemDeleteChild(treeItem, itemName);
                        continue;
                    }
                    methodSync.Add(method);
                    methodCount++;
                }
            }

            if (propCount < info.ValueT.ACClassProperty_ACClass.Count(c => c.IsRPCEnabled))
            {
                AddProperty(treeItem, propSync);
                propSync = null;
            }
            if (methodCount < info.ValueT.ACClassMethod_ACClass.Count(c => c.IsRPCEnabled))
            {
                AddMethods(treeItem, methodSync);
                methodSync = null;
            }
        }

        /// <summary>
        /// Add default methods (FB_init).
        /// </summary>
        /// <param name="pou">The POU.</param>
        private void AddDefaultMethods(ITcSmTreeItem pou)
        {
            dynamic vInfo = new string[4];
            vInfo[0] = "ST";
            vInfo[1] = "BOOL";
            vInfo[2] = "PUBLIC";
            vInfo[3] = "";

            ITcSmTreeItem methodInit = ITCSmTreeItemCreateChild(pou, "FB_init", ItemType.Method, "", (object)vInfo);

            string declText = @"METHOD FB_init : BOOL" + System.Environment.NewLine +
                    "VAR_INPUT" + System.Environment.NewLine +
                    "   bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)" + System.Environment.NewLine +
                    "   bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)" + System.Environment.NewLine +
                    "   parent : IACComponent;" + System.Environment.NewLine +
                    "END_VAR" + System.Environment.NewLine +
                    "VAR" + System.Environment.NewLine +
                    "END_VAR";

            ITCPlcDeclarationTextSet(methodInit, declText);
        }

        /// <summary>
        /// Add methods marked with IsRPCEnabled attribute to plc pou.
        /// </summary>
        /// <param name="pou">The pou.</param>
        /// <param name="methods">List of acClass methods.</param>
        private void AddMethods(ITcSmTreeItem pou, IEnumerable<ACClassMethod> methods)
        {
            foreach (var method in methods.Where(c => c.IsRPCEnabled))
            {
                string[] vInfo = new string[4];
                vInfo[0] = "ST";
                vInfo[1] = TranslateType(method.ObjectType);
                vInfo[2] = "PUBLIC";
                vInfo[3] = "";

                ITCSmTreeItemCreateChild(pou, method.ACIdentifier, ItemType.Method, "", vInfo);
            }
        }

        /// <summary>
        /// Translate type from C# to StructuredText.
        /// </summary>
        /// <param name="inType">The C# type.</param>
        /// <returns>StructuredText type in string.</returns>
        private string TranslateType(Type inType)
        {
            if (inType == typeof(bool))
                return "BOOL";
            else if (inType == typeof(string))
                return "STRING";
            else if (inType == typeof(DateTime))
                return "DATE_AND_TIME";
            else if (inType == typeof(byte))
                return "BYTE";
            else if (inType == typeof(TimeSpan))
                return "TIME";
            else if (inType == typeof(short))
                return "INT";
            else if (inType == typeof(int))
                return "DINT";
            else if (inType == typeof(ushort))
                return "UINT";
            else if (inType == typeof(uint))
                return "UDINT";
            else if (inType == typeof(double))
                return "LREAL";
            else if (inType == typeof(float))
                return "REAL";
            return "";
        }

        /// <summary>
        /// Delete folder or POU.
        /// </summary>
        /// <param name="info">The ACClassInfoWithItems (acClass).</param>
        /// <param name="parentTreeItem">The parent folder.</param>
        /// <param name="pouName">The POU name.</param>
        private void DeleteFolderOrPou(ACClassInfoWithItems info, ITcSmTreeItem parentTreeItem, string pouName)
        {
            ITcSmTreeItem pou = FindTreeItem(info.ACIdentifier, parentTreeItem);
            if (pou != null && ITCAction(() => pou.ItemType) == (int)ItemType.Folder)
            {
                ResolveFolderPOUsForDelete(pou);
                ITCSmTreeItemDeleteChild(parentTreeItem, info.ACIdentifier);
            }
            else
            {
                ITCSmTreeItemDeleteChild(parentTreeItem, pouName);
                _pouDeleteCache.Add(pouName);
            }
        }

        public void ResolveFolderPOUsForDelete(ITcSmTreeItem folder)
        {
            if (ITCAction(() => folder.ItemType) != (int)ItemType.Folder)
                return;

            foreach (ITcSmTreeItem treeItem in ITcSmTreeItemList(folder))
            {
                if (ITCAction(() => treeItem.ItemType) == (int)ItemType.Folder)
                    ResolveFolderPOUsForDelete(treeItem);
                else
                {
                    string name = ITCAction(() => treeItem.Name);
                    if (!string.IsNullOrEmpty(name))
                        _pouDeleteCache.Add(name);
                }
            }
        }

        /// <summary>
        /// Delete POU data from implementation and declaration, after delete POU. 
        /// </summary>
        /// <param name="pouName">The POU name.</param>
        /// <param name="parentItem">The parent POU.</param>
        private void DeleteFromImplementationAndDeclaration(string pouName, ITcSmTreeItem parentItem)
        {
            ITcSmTreeItem parentTreePou = parentItem;
            if (ITCAction(() => parentItem.ItemType) == (int)ItemType.Folder)
            {
                foreach (ITcSmTreeItem item in ITcSmTreeItemList(parentItem))
                {
                    if (ITCAction(() => item.Name).Split(delimiter, StringSplitOptions.RemoveEmptyEntries).LastOrDefault() == ITCAction(() => parentItem.Name))
                    {
                        parentTreePou = item;
                        break;
                    }
                }
            }

            string declaration = ITCAction(() => parentTreePou is ITcPlcDeclaration ? ((ITcPlcDeclaration)parentTreePou).DeclarationText : null);
            string nameForRemove = "";

            using (StringReader reader = new StringReader(declaration))
            {
                StringBuilder sb = new StringBuilder();
                string line = "";
                do
                {
                    line = reader.ReadLine();
                    if (line != null)
                    {
                        if (!line.Contains(pouName))
                            sb.AppendLine(line);
                        else
                            nameForRemove = line.Split(':').FirstOrDefault().Trim();
                    }
                }
                while (line != null);
                ITCPlcDeclarationTextSet(parentTreePou, sb.ToString());
            }

            ITcSmTreeItem fbChildInit = parentTreePou.LookupChild("FB_childinit");

            string implementation = ITCAction(() => fbChildInit is ITcPlcImplementation ? ((ITcPlcImplementation)fbChildInit).ImplementationText : null);

            using (StringReader reader = new StringReader(implementation))
            {
                StringBuilder sb = new StringBuilder();
                string line = "";
                do
                {
                    line = reader.ReadLine();
                    if (line != null)
                    {
                        if (!line.Contains(nameForRemove))
                            sb.AppendLine(line);
                    }
                }
                while (line != null);
                ITCPlcImplementationTextSet(fbChildInit, sb.ToString());
            }
        }

        /// <summary>
        /// Delete edge from source.
        /// </summary>
        /// <param name="target">The target POU.</param>
        private void ResolveEdgesForDelete(ITcSmTreeItem target)
        {
            if (target == null)
                return;

            if (ITCAction(() => target.ItemType) == (int)ItemType.Folder)
            {
                foreach (ITcSmTreeItem treeItem in ITcSmTreeItemList(target))
                {
                    ResolveEdgeNameForDelete(treeItem);
                }
            }
            else
            {
                ResolveEdgeNameForDelete(target);
            }
        }

        private void ResolveEdgeNameForDelete(ITcSmTreeItem pou)
        {
            ITcSmTreeItem fbPostInit = FindTreeItem("FB_postinit", pou);

            if (fbPostInit == null)
                return;

            string postInitImplementation = ITCAction(() => fbPostInit is ITcPlcImplementation ? ((ITcPlcImplementation)fbPostInit).ImplementationText : "");
            using (StringReader reader = new StringReader(postInitImplementation))
            {
                string line = "";
                do
                {
                    line = reader.ReadLine();
                    if (line != null)
                    {
                        if (line.Contains(".AddEdge"))
                        {
                            string propName = line.Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault().Trim();
                            int startIndex = line.IndexOf('(')+1;
                            string edgeName = line.Substring(startIndex, line.IndexOf(')') - startIndex);
                            _edgeDeleteCache.Add(new Tuple<string, string>(propName, edgeName));
                        }
                    }
                }
                while (line != null);
            }
        }

        /// <summary>
        /// Delete edge declaration and implementation from pou.
        /// </summary>
        /// <param name="treeItem">The source POU.</param>
        /// <param name="edgeName">The edge name.</param>
        private void DeleteEdgeFromPouDeclarationAndImplementation(ITcSmTreeItem treeItem, string edgeName)
        {
            string declaration = ITCAction(() => treeItem is ITcPlcDeclaration ? ((ITcPlcDeclaration)treeItem).DeclarationText : null);
            using (StringReader reader = new StringReader(declaration))
            {
                string line = "";
                StringBuilder sb = new StringBuilder();
                do
                {
                    line = reader.ReadLine();
                    if (line != null)
                    {
                        if (!line.Contains(edgeName))
                            sb.AppendLine(line);
                    }
                }
                while (line != null);
                ITCPlcDeclarationTextSet(treeItem, sb.ToString());
            }

            ITcSmTreeItem fbInit = FindTreeItem("FB_postinit", treeItem);
            string implementation = ITCAction(() => fbInit is ITcPlcImplementation ? ((ITcPlcImplementation)fbInit).ImplementationText : null);
            using (StringReader reader = new StringReader(implementation))
            {
                string line = "";
                StringBuilder sb = new StringBuilder();
                do
                {
                    line = reader.ReadLine();
                    if (line != null)
                    {
                        if (!line.Contains(edgeName))
                            sb.AppendLine(line);
                    }
                }
                while (line != null);
                ITCPlcImplementationTextSet(fbInit, sb.ToString());
            }
        }

        /// <summary>
        /// Check if folder contains only one POU, then move POU to parent folder and delete folder.
        /// </summary>
        /// <param name="folder">The parent folder.</param>
        /// <param name="info">The ACClassInfoWithItems (acClass).</param>
        private void CheckAndMoveAfterDelete(ITcSmTreeItem folder, ACClassInfoWithItems info)
        {
            if (ITCAction(() => folder.ItemType) == (int)ItemType.Folder && folder.ChildCount == 1)
            {
                string pouName = folder.Child[1].Name;
                folder.Child[1].Name = pouName + "TEMP";
                ITcSmTreeItem parent = ITCAction(() => folder.Parent);
                ITcSmTreeItem pou = parent.CreateChild(pouName, (int)ItemType.Pou, "", "ST");
                CopyPou(folder.Child[1], pou);
                ITCSmTreeItemDeleteChild(parent, ITCAction(() => folder.Name));
                _acClassInfoMovedName = pouName;
            }
        }

        /// <summary>
        /// Check and set change info.
        /// </summary>
        /// <param name="info">The ACClassInfoWithItems (acClass).</param>
        private void CheckAndSetChangeInfo(ACClassInfoWithItems info)
        {
            if (!info.Items.OfType<ACClassInfoWithItems>().Any(c => (Global.ChangeTypeEnum)c.IconState != Global.ChangeTypeEnum.None))
            {
                info.IconState = Global.ChangeTypeEnum.None;
                if (info.ParentACObject != null)
                    CheckAndSetChangeInfo(info.ParentACObject as ACClassInfoWithItems);
            }
            else
                info.IconState = Global.ChangeTypeEnum.Changed;
        }

        /// <summary>
        /// Check if project item name contains unallowed characters.
        /// </summary>
        /// <param name="info">The ACClassInfoWithItems (acClass).</param>
        private void CheckProjectItemsName(ACClassInfoWithItems info)
        {
            if (!info.ACIdentifier.All(c => Char.IsLetterOrDigit(c) || c.Equals('_')))
                _WrongItemsNameList.Add(info.ACIdentifier);
            if (info.ValueT != null)
                CheckPropertyAndMethodName(info.ValueT);

            foreach (ACClassInfoWithItems item in info.Items)
                CheckProjectItemsName(item);
        }

        /// <summary>
        /// Check if property or method name contains unallowed characters.
        /// </summary>
        /// <param name="acClass">The acClass.</param>
        private void CheckPropertyAndMethodName(ACClass acClass)
        {
            //todo: filter property and metod after param added
            foreach (var prop in acClass.ACClassProperty_ACClass.Where(c => c.IsRPCEnabled))
            {
                if (!prop.ACIdentifier.All(c => Char.IsLetterOrDigit(c) || c.Equals('_')))
                    _WrongItemsNameList.Add(acClass.ACIdentifier + " => Property: " + prop.ACIdentifier);
            }
            foreach (var method in acClass.ACClassMethod_ACClass.Where(c => c.IsRPCEnabled))
            {
                if (!method.ACIdentifier.All(c => Char.IsLetterOrDigit(c) || c.Equals('_')))
                    _WrongItemsNameList.Add(acClass.ACIdentifier + " => Method: " + method.ACIdentifier);
            }
        }


        string _mainDecl = "";
        string _mainEdgeDecl = "";
        List<Tuple<string, string>> _edgeDeleteCache;
        List<string> _pouDeleteCache;

        private void CreateMainDeclarationAndImplementation(string fullName)
        {
            string parentName = "";
            string shortName = "";
            if (!fullName.Contains("_I_"))
            {
                parentName = "VB";
                shortName = fullName;
            }
            else
            {
                parentName = fullName.Substring(0, fullName.Length - (fullName.Length - fullName.LastIndexOf("_I_")));
                shortName = fullName.Substring(fullName.LastIndexOf("_I_") + 3);
            }

            string instance = string.Format("_{0} : {0}(_{1});", fullName, parentName);

            if (!_mainDecl.Contains(instance))
                _mainDecl += System.Environment.NewLine + _4spaces + instance;
        }

        #endregion

        #region Methods -> Helper

        /// <summary>
        /// Generate POU path to root depends on ACClassInfoWithItems;
        /// </summary>
        /// <param name="info">The ACClassInfoWithItems (acClass).</param>
        /// <returns>POU path to root.</returns>
        private string GeneratePouPathToRoot(ACClassInfoWithItems info)
        {
            string path = FindPouName(info);
            if (info.Items.OfType<ACClassInfoWithItems>().Any(c => (Global.ChangeTypeEnum)c.IconState != Global.ChangeTypeEnum.Added) && path != info.ACIdentifier)
            {
                path = path.Insert(0, info.ACIdentifier + "^");
            }
            while (info.ParentACObject != null)
            {
                info = info.ParentACObject as ACClassInfoWithItems;
                if (info.Items.OfType<ACClassInfoWithItems>().Any(c => (Global.ChangeTypeEnum)c.IconState != Global.ChangeTypeEnum.Added))
                    path = path.Insert(0, info.ACIdentifier + "^");
                else
                    path = path.Insert(0, FindPouName(info) + "^");
            }
            return path;
        }

        private string GeneratePouPathToRootForAddedState(ACClassInfoWithItems info, bool withFolder = true)
        {
            string path = FindPouName(info);
            if (info.Items.OfType<ACClassInfoWithItems>().Any(c => c.IsChecked) && path != info.ACIdentifier && withFolder)
            {
                path = path.Insert(0, info.ACIdentifier + "^");
            }
            while (info.ParentACObject != null)
            {
                info = info.ParentACObject as ACClassInfoWithItems;
                if (info.Items.OfType<ACClassInfoWithItems>().Any(c => (Global.ChangeTypeEnum)c.IconState != Global.ChangeTypeEnum.Added))
                    path = path.Insert(0, info.ACIdentifier + "^");
                else
                    path = path.Insert(0, FindPouName(info) + "^");
            }
            return path;
        }

        /// <summary>
        /// Find POU from root (CurrentPOU's).
        /// </summary>
        /// <param name="pouName">The pou name.</param>
        /// <returns>POU if found else retun null.</returns>
        private ITcSmTreeItem FindPouFromRoot(string pouName)
        {
            string[] parts = pouName.Split(delimiter, StringSplitOptions.RemoveEmptyEntries);
            ITcSmTreeItem currentTreeItem = CurrentPOU;

            foreach (string part in parts)
            {
                ITcSmTreeItem item = FindTreeItem(part, currentTreeItem);
                if (item != null && ITCAction(() => item.ItemType) == (int)ItemType.Folder)
                    currentTreeItem = item;
                else
                {
                    item = FindTreeItem(pouName, currentTreeItem);
                    if (item != null)
                        return item;
                }

                if (item != null && ITCAction(() => item.Name) == parts.LastOrDefault())
                {
                    item = FindTreeItem(pouName, currentTreeItem);
                    if (item != null)
                        return item;
                }

            }
            return null;
        }

        private string FindPouName(ACClassInfoWithItems info)
        {
            string name = info.ACIdentifier;
            while (info.ParentACObject != null)
            {
                info = info.ParentACObject as ACClassInfoWithItems;
                name = name.Insert(0, info.ACIdentifier + "_I_");
            }
            return name;
        }

        private string FindPouName(ACClass acClass)
        {
            string name = acClass.ACIdentifier;
            while (acClass.ACClass1_ParentACClass != null)
            {
                acClass = acClass.ACClass1_ParentACClass;
                name = name.Insert(0, acClass.ACIdentifier + "_I_");
            }
            return name;
        }

        private ITcSmTreeItem FindTreeItem(string treeItemName, ITcSmTreeItem parent, int maxTries = 300, int sleepms = 50)
        {
            ITcSmTreeItem result = null;
            for (int i = 0; i < maxTries; i++)
            {
                try
                {
                    result = parent.LookupChild(treeItemName);
                    return result;
                }
                catch (Exception e)
                {
                    //exception: tree item not found => return null
                    if (e.HResult == -1739522047)
                        return null;
                    else if (e.HResult == -2147417846 || e.HResult == -2146233088 || e.HResult == -2147418111)
                        System.Threading.Thread.Sleep(sleepms);
                    else
                        throw new Exception(e.Message);
                }
            }
            return result;
        }

        private void SetAllToAdded(ACClassInfoWithItems info)
        {
            info.IconState = Global.ChangeTypeEnum.Added;
            foreach (ACClassInfoWithItems item in info.Items)
                SetAllToAdded(item);
        }

        private void SetAllToNone(ACClassInfoWithItems info)
        {
            info.IconState = Global.ChangeTypeEnum.None;
            foreach (ACClassInfoWithItems item in info.Items)
                SetAllToNone(item);
        }

        private void SetIsCheckedOnCurrentProject(ACClassInfoWithItems currentProject, ITcSmTreeItem currentTreeItem)
        {
            foreach (ITcSmTreeItem treeItem in ITcSmTreeItemList(currentTreeItem))
            {
                if (ITCAction(() => treeItem.Name).Contains("_I_"))
                    SetCheckOnInfo(ITCAction(() => treeItem.Name), currentProject);

                SetIsCheckedOnCurrentProject(currentProject, treeItem);
            }
        }

        private void SetCheckOnInfo(string tcPath, ACClassInfoWithItems currentProject)
        {
            string[] delimiter = new string[1];
            delimiter[0] = _TCdelimiter;
            var acIdentifiers = tcPath.Split(delimiter, StringSplitOptions.RemoveEmptyEntries);

            foreach (string acIdentifier in acIdentifiers)
            {
                if (currentProject != null && acIdentifier == currentProject.ACIdentifier)
                {
                    currentProject.IsChecked = true;
                }
                else if (currentProject != null && !string.IsNullOrEmpty(acIdentifier))
                {
                    currentProject = currentProject.Items.FirstOrDefault(c => c.ACIdentifier == acIdentifier) as ACClassInfoWithItems;
                    if (currentProject != null)
                        currentProject.IsChecked = true;
                }
            }
        }

        private void UnCheckAllInfo(ACClassInfoWithItems info)
        {
            info.IsChecked = false;
            foreach (ACClassInfoWithItems item in info.Items)
                UnCheckAllInfo(item);
        }

        private void CopyPou(ITcSmTreeItem copyFrom, ITcSmTreeItem copyTo)
        {
            ITCPlcDeclarationTextSet(copyTo, ITCAction(() => copyFrom is ITcPlcDeclaration ? ((ITcPlcDeclaration)copyFrom).DeclarationText : null));
            ITCPlcImplementationTextSet(copyTo, ITCAction(() => copyFrom is ITcPlcImplementation ? ((ITcPlcImplementation)copyFrom).ImplementationText : null));

            foreach (ITcSmTreeItem item in ITcSmTreeItemList(copyFrom))
            {
                ITcSmTreeItem copyToItem = FindTreeItem(ITCAction(() => item.Name), copyTo);
                if (copyToItem == null)
                    copyToItem = ITCSmTreeItemCreateChild(copyTo, ITCAction(() => item.Name), (ItemType)ITCAction(() => item.ItemType), "", "ST");
                //copyToItem = copyTo.CreateChild(ITCSmTreeItemName(item), item.ItemType, "", "ST");

                if (ITCAction(() => item.ItemType) == (int)ItemType.Property)
                {
                    ITCPlcDeclarationTextSet(copyToItem, ITCAction(() => item is ITcPlcDeclaration ? ((ITcPlcDeclaration)item).DeclarationText : null));
                    foreach (ITcSmTreeItem itemProp in ITcSmTreeItemList(item))
                    {
                        ITcSmTreeItem copyToItemProp = FindTreeItem(ITCAction(() => itemProp.Name), copyToItem);
                        if (copyToItemProp == null)
                            copyToItemProp = ITCSmTreeItemCreateChild(copyToItem, ITCAction(() => itemProp.Name), (ItemType)ITCAction(() => itemProp.ItemType), "", "ST");

                        ITCPlcDeclarationTextSet(copyToItemProp, ITCAction(() => ((ITcPlcDeclaration)itemProp).DeclarationText));
                        //ITCPlcImplementationTextSet(copyToItemProp, ITCPlcImplementationText(itemProp));
                    }
                }
                else
                {
                    ITCPlcDeclarationTextSet(copyToItem, ITCAction(() => item is ITcPlcDeclaration ? ((ITcPlcDeclaration)item).DeclarationText : null));
                    ITCPlcImplementationTextSet(copyToItem, ITCAction(() => item is ITcPlcImplementation ? ((ITcPlcImplementation)item).ImplementationText : null));
                }
            }
        }

        private bool CheckIsAnyChecked(ACClassInfoWithItems acClassInfoWithItems)
        {
            if (acClassInfoWithItems.IsChecked)
                return true;
            foreach (ACClassInfoWithItems info in acClassInfoWithItems.Items)
            {
                if (info.IsChecked)
                    return true;
                if (CheckIsAnyChecked(info))
                    return true;
            }
            return false;
        }

        private int CountProjectItems(ACClassInfoWithItems rootItem, bool onlyChecked = false)
        {
            int result = 0;
            CountRecursive(rootItem, onlyChecked, ref result);
            return result;
        }

        private void CountRecursive(ACClassInfoWithItems info, bool onlyChecked, ref int result)
        {
            if (onlyChecked)
            {
                if (info.IsChecked)
                    result++;
            }
            else
                result++;
           
            foreach (ACClassInfoWithItems item in info.Items)
                CountRecursive(item, onlyChecked, ref result);
        }

        private List<ITcSmTreeItem> ITcSmTreeItemList(ITcSmTreeItem treeItem, int maxTries = 300, int sleepms = 50)
        {
            List<ITcSmTreeItem> list = new List<ITcSmTreeItem>();
            if (treeItem == null)
                return list;

            for (int i = 0; i < maxTries; i++)
            {
                try
                {
                    foreach (ITcSmTreeItem item in treeItem)
                    {
                        if (!list.Any(c => c.Name == ITCAction(() => item.Name)))
                            list.Add(item);
                    }
                    return list;
                }
                catch (Exception e)
                {
                    if (e.HResult == -2147417846 || e.HResult == -2146233088 || e.HResult == -2147418111)
                        System.Threading.Thread.Sleep(sleepms);
                    else if (i == maxTries - 1)
                    {
                        Messages.Error(this, string.Format("Exception:{0}", e.Message), true);
                        break;
                    }
                    else
                    {
                        Messages.Error(this, string.Format("Exception:{0}", e.Message), true);
                        break;
                    }
                }
            }
            return list;
        }

        private void ITCPlcImplementationTextSet(ITcSmTreeItem treeItem, string implementationText)
        {
            if (implementationText == null)
                return;
            ITCAction(() => ((ITcPlcImplementation)treeItem).ImplementationText = implementationText);
        }

        private void ITCPlcDeclarationTextSet(ITcSmTreeItem treeItem, string declarationText)
        {
            if (declarationText == null)
                return;
            ITCAction(() => ((ITcPlcDeclaration)treeItem).DeclarationText = declarationText);
        }

        private ITcSmTreeItem ITCSmTreeItemCreateChild(ITcSmTreeItem parent, string name, ItemType type, string bstrBefore, object vInfo)
        {
            return ITCAction(() => parent.CreateChild(name, (int)type, bstrBefore, vInfo));
        }

        private void ITCSmTreeItemDeleteChild(ITcSmTreeItem parent, string name)
        {
            ITCAction(() => parent.DeleteChild(name), 500, 100);
        }

        private T ITCAction<T>(Func<T> action, int maxTries = 400, int sleepms = 50)
        {
            T result = default(T);
            for (int i = 0; i < maxTries; i++)
            {
                try
                {
                    result = action();
                    break;
                }
                catch (Exception e)
                {
                    if (e.HResult == -2147417846 || e.HResult == -2146233088 || e.HResult == -2147418111)
                        System.Threading.Thread.Sleep(sleepms);
                    else if (i == maxTries - 1)
                    {
                        Messages.Error(this, string.Format("Exception:{0}", e.Message), true);
                        break;
                    }
                    else
                    {
                        Messages.Error(this, string.Format("Exception:{0}", e.Message), true);
                        break;
                    }

                }
            }
            return result;
        }

        private void ITCAction(Action action, int maxTries = 300, int sleepms = 50)
        {
            for (int i = 0; i < maxTries; i++)
            {
                try
                {
                    action();
                    break;
                }
                catch (Exception e)
                {
                    if (e.HResult == -2147417846 || e.HResult == -2146233088 || e.HResult == -2147418111)
                        System.Threading.Thread.Sleep(sleepms);
                    else if (i == maxTries - 1)
                    {
                        Messages.Error(this, string.Format("Exception:{0}", e.Message), true);
                        break;
                    }
                    else
                    {
                        Messages.Error(this, string.Format("Exception:{0}", e.Message), true);
                        break;
                    }
                }
            }
        }

        private int ITCSmTreeItemChildCount(ITcSmTreeItem treeItem)
        {
            return ITcSmTreeItemList(treeItem).Count(c => !ITCAction(() => c.Name).StartsWith("USER"));
        }

        #endregion

        #endregion

        #region BgWorker

        public override void BgWorkerDoWork(object sender, System.ComponentModel.DoWorkEventArgs e)
        {
            base.BgWorkerDoWork(sender, e);
            if (e.Argument.ToString() == "OpenSolution")
                OpenSolution();

            else if (e.Argument.ToString() == "SyncProjects")
                SyncProj();

            else if (e.Argument.ToString() == "CompareProjects")
                CompareProjects(CurrentProjectItemRoot, CurrentPOU);
        }

        #endregion

        /// <summary>Called inside the GetControlModes-Method to get the Global.ControlModes from derivations.
        /// This method should be overriden in the derivations to dynmically control the presentation mode depending on the current value which is bound via VBContent</summary>
        /// <param name="vbControl">A WPF-Control that implements IVBContent</param>
        /// <returns>ControlModesInfo</returns>
        public override Global.ControlModes OnGetControlModes(IVBContent vbControl)
        {
            var cm = base.OnGetControlModes(vbControl);

            if (vbControl.VBContent == "CurrentACProject")
            {
                if (CurrentPOU == null)
                    cm = Global.ControlModes.Disabled;
                else
                    cm = Global.ControlModes.Enabled;
            }

            return cm;
        }

        #region Execute-Helper-Handlers

        protected override bool HandleExecuteACMethod(out object result, AsyncMethodInvocationMode invocationMode, string acMethodName, core.datamodel.ACClassMethod acClassMethod, params object[] acParameter)
        {
            result = null;
            switch (acMethodName)
            {
                case "OpenSolutionPath":
                    OpenSolutionPath();
                    return true;
                case "IsEnabledOpenSolutionPath":
                    result = IsEnabledOpenSolutionPath();
                    return true;
                case "LoadSolution":
                    LoadSolution();
                    return true;
                case "IsEnabledLoadSolution":
                    result = IsEnabledLoadSolution();
                    return true;
                case "UnloadSolution":
                    UnloadSolution();
                    return true;
                case "IsEnabledUnloadSolution":
                    result = IsEnabledUnloadSolution();
                    return true;
                case "SyncProjects":
                    SyncProjects();
                    return true;
                case "IsEnabledSyncProjects":
                    result = IsEnabledSyncProjects();
                    return true;
            }
            return base.HandleExecuteACMethod(out result, invocationMode, acMethodName, acClassMethod, acParameter);
        }

        #endregion
    }
}
