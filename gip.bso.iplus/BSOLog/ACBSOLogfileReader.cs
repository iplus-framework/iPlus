// Copyright (c) 2024, gipSoft d.o.o.
// Licensed under the GNU GPLv3 License. See LICENSE file in the project root for full license information.
using gip.core.autocomponent;
using gip.core.datamodel;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using gip.core.media;

namespace gip.bso.iplus
{
    /// <summary>
    /// Business object for reading and filtering log files generated by Messages.cs
    /// Messages.cs normaly writes the log files to a temporary folder on server side Messages.LogFilePath (Path.GetTempPath()).
    /// Copy this file from the server into a local folder and use this component to read and analyze the log file.
    /// Specifiy the log file path in the SelectedLogFile property.
    /// Call LoadLogFile() to load the log file and parse it. The loaded log lines are available in the LogLines property. This method runs asynchronously. Check if BackgroundWorker.IsBusy is false to see if loading is finished.
    /// Set the SearchFilter property to filter the log lines. Call ApplyFilter(). The resulting filtered log lines are available in the FilteredLogLines property.
    /// Select with SelectedAnalyzer property an analyzer from the AvailableAnalyzers property to analyze the filtered log lines.
    /// Specify the output file path in the OutputFilePath property.
    /// Call StartAnalysis() to start the analysis. This method runs asynchronously. Check if BackgroundWorker.IsBusy is false to see if the analysis is finished.
    /// Available analyzers are child components of this business obejct. You can create your own analyzers by deriving from ACBSOLogfileAnalyzerBase and use BSOiPlusStudio to add them as Child Components to this component.
    /// </summary>
    [ACClassInfo(
        Const.PackName_VarioSystem,
        "en{'Log File Reader'}de{'Log-Datei-Leser'}",
        Global.ACKinds.TACBSO,
        Global.ACStorableTypes.NotStorable,
        true,
        true,
        Description =
    @"Business object for reading and filtering log files generated by Messages.cs
    Messages.cs normaly writes the log files to a temporary folder on server side Messages.LogFilePath (Path.GetTempPath()).
    Copy this file from the server into a local folder and use this component to read and analyze the log file.
    Specifiy the log file path in the SelectedLogFile property.
    Call LoadLogFile() to load the log file and parse it. The loaded log lines are available in the LogLines property. This method runs asynchronously. Check if BackgroundWorker.IsBusy is false to see if loading is finished.
    Set the SearchFilter property to filter the log lines. Call ApplyFilter(). The resulting filtered log lines are available in the FilteredLogLines property.
    Select with SelectedAnalyzer property an analyzer from the AvailableAnalyzers property to analyze the filtered log lines.
    Specify the output file path in the OutputFilePath property.
    Call StartAnalysis() to start the analysis. This method runs asynchronously. Check if BackgroundWorker.IsBusy is false to see if the analysis is finished.
    Available analyzers are child components of this business obejct. You can create your own analyzers by deriving from ACBSOLogfileAnalyzerBase and use BSOiPlusStudio to add them as Child Components to this component."
    )]
    public class ACBSOLogfileReader : ACBSO
    {
        #region c'tors

        /// <summary>
        /// Creates a new instance of ACBSOLogfileReader.
        /// </summary>
        public ACBSOLogfileReader(ACClass acType, IACObject content, IACObject parentACObject, ACValueList parameter, string acIdentifier = "") :
            base(acType, content, parentACObject, parameter, acIdentifier)
        {
        }

        /// <summary>
        /// Initializes this component.
        /// </summary>
        public override bool ACInit(Global.ACStartTypes startChildMode = Global.ACStartTypes.Automatic)
        {
            _LogLines = new ObservableCollection<LogfileReaderLine>();
            _FilteredLogLines = new ObservableCollection<LogfileReaderLine>();
            _AvailableAnalyzers = new ACValueItemList("AvailableAnalyzers");
            bool baseInit =  base.ACInit(startChildMode);
            if (baseInit)
                LoadAvailableAnalyzers();
            return baseInit;
        }

        /// <summary>
        /// Deinitializes this component.
        /// </summary>
        public override async Task<bool> ACDeInit(bool deleteACClassTask = false)
        {
            _LogLines?.Clear();
            _FilteredLogLines?.Clear();
            _AvailableAnalyzers?.Clear();
            _SelectedLogFile = null;
            _SearchFilter = null;
            _SelectedAnalyzer = null;
            _CurrentAnalyzerInstance = null;

            return await base.ACDeInit(deleteACClassTask);
        }

        #endregion

        #region Properties

        private string _SelectedLogFile;
        /// <summary>
        /// Gets or sets the currently selected log file path.
        /// </summary>
        [ACPropertyInfo(401, "", "en{'Selected Log File'}de{'Ausgewählte Log-Datei'}", Description = "Path to the logfile")]
        public string SelectedLogFile
        {
            get => _SelectedLogFile;
            set
            {
                _SelectedLogFile = value;
                OnPropertyChanged();
            }
        }

        private string _SearchFilter;
        /// <summary>
        /// Gets or sets the search filter (multi-line, separated by carriage return).
        /// </summary>
        [ACPropertyInfo(402, "", "en{'Search Filter (Source _ ACName per line)'}de{'Suchfilter (Source _ ACName pro Zeile)'}", Description = "Separate the Source and ACName by a Space")]
        public string SearchFilter
        {
            get => _SearchFilter;
            set
            {
                _SearchFilter = value;
                OnPropertyChanged();
            }
        }

        private ObservableCollection<LogfileReaderLine> _LogLines;
        /// <summary>
        /// Gets the collection of all log lines.
        /// </summary>
        [ACPropertyList(403, "LogLines")]
        public ObservableCollection<LogfileReaderLine> LogLines
        {
            get => _LogLines;
            set
            {
                _LogLines = value;
                OnPropertyChanged();
            }
        }

        private ObservableCollection<LogfileReaderLine> _FilteredLogLines;
        /// <summary>
        /// Gets the collection of filtered log lines.
        /// </summary>
        [ACPropertyList(404, "FilteredLogLines")]
        public ObservableCollection<LogfileReaderLine> FilteredLogLines
        {
            get => _FilteredLogLines;
            set
            {
                _FilteredLogLines = value;
                OnPropertyChanged();
            }
        }

        private LogfileReaderLine _SelectedLogLine;
        /// <summary>
        /// Gets or sets the currently selected log line.
        /// </summary>
        [ACPropertySelected(405, "LogLines")]
        public LogfileReaderLine SelectedLogLine
        {
            get => _SelectedLogLine;
            set
            {
                _SelectedLogLine = value;
                OnPropertyChanged();
            }
        }

        private ACValueItemList _AvailableAnalyzers;
        /// <summary>
        /// Gets the list of available analyzer types.
        /// </summary>
        [ACPropertyList(406, "AvailableAnalyzers")]
        public ACValueItemList AvailableAnalyzers
        {
            get => _AvailableAnalyzers;
            set
            {
                _AvailableAnalyzers = value;
                OnPropertyChanged();
            }
        }

        private ACValueItem _SelectedAnalyzer;
        /// <summary>
        /// Gets or sets the currently selected analyzer.
        /// </summary>
        [ACPropertySelected(407, "AvailableAnalyzers")]
        public ACValueItem SelectedAnalyzer
        {
            get => _SelectedAnalyzer;
            set
            {
                _SelectedAnalyzer = value;
                if (_SelectedAnalyzer == null)
                {
                    CurrentAnalyzerInstance = null;
                }
                else
                {
                    string analyzerID = _SelectedAnalyzer.Value as string;
                    CurrentAnalyzerInstance = FindChildComponents<ACBSOLogfileAnalyzerBase>(c => c is ACBSOLogfileAnalyzerBase && c.ACIdentifier == analyzerID).FirstOrDefault();
                }

                OnPropertyChanged();
            }
        }

        private ACBSOLogfileAnalyzerBase _CurrentAnalyzerInstance;
        /// <summary>
        /// Gets the current analyzer instance.
        /// </summary>
        public ACBSOLogfileAnalyzerBase CurrentAnalyzerInstance
        {
            get => _CurrentAnalyzerInstance;
            set
            {
                _CurrentAnalyzerInstance = value;
                OnPropertyChanged();
                OnPropertyChanged(nameof(OutputFilePath));
            }
        }

        [ACPropertyInfo(410, "", "en{'Output File Path'}de{'Ausgabedatei-Pfad'}", Description = "Path to the otuput file that should be generated from the selected Analyzer")]
        public string OutputFilePath
        {
            get => CurrentAnalyzerInstance?.OutputFilePath;
        }

        private int _ProcessingProgress;
        /// <summary>
        /// Gets or sets the processing progress percentage.
        /// </summary>
        [ACPropertyInfo(408, "", "en{'Progress'}de{'Fortschritt'}")]
        public int ProcessingProgress
        {
            get => _ProcessingProgress;
            set
            {
                _ProcessingProgress = value;
                OnPropertyChanged();
            }
        }

        private bool _IsProcessing;
        /// <summary>
        /// Gets or sets whether processing is currently running.
        /// </summary>
        [ACPropertyInfo(409, "", "en{'Is Processing'}de{'Wird verarbeitet'}")]
        public bool IsProcessing
        {
            get => _IsProcessing;
            set
            {
                _IsProcessing = value;
                OnPropertyChanged();
            }
        }

        #endregion

        #region Methods

        /// <summary>
        /// Opens a file dialog to select a log file.
        /// </summary>
        [ACMethodCommand("", "en{'Select Log File'}de{'Log-Datei auswählen'}", 401)]
        public async Task SelectLogFile()
        {
            try
            {
                ACMediaController mediaController = ACMediaController.GetServiceInstance(this);
                string filePath = await mediaController.OpenFileDialog(
                    false,
                    SelectedLogFile,
                    false,
                    null,
                    new Dictionary<string, string>()
                    {
                    {
                        "Select Log File",
                        "*.txt, *.log"
                    }
                    });

                if (filePath != null && Directory.Exists(Path.GetDirectoryName(filePath)))
                {
                    SelectedLogFile = filePath;
                }
            }
            catch (Exception ex)
            {
                Messages.LogException(this.GetACUrl(), "SelectLogFile", ex);
                await Root.Messages.ErrorAsync(this, "Error selecting log file: " + ex.Message, true);
            }
        }

        /// <summary>
        /// Loads the selected log file and parses it.
        /// </summary>
        [ACMethodCommand("", "en{'Load Log File'}de{'Log-Datei laden'}", 402)]
        public async void LoadLogFile()
        {
            if (!IsEnabledLoadLogFile())
            {
                await Root.Messages.WarningAsync(this, "Please select a valid log file first.", true);
                return;
            }
            CloseTopDialog();
            BackgroundWorker.RunWorkerAsync(nameof(ParseLogFile));
            await ShowDialogAsync(this, DesignNameProgressBar);

        }

        public bool IsEnabledLoadLogFile()
        {
            return !string.IsNullOrEmpty(SelectedLogFile) && File.Exists(SelectedLogFile) && !BackgroundWorker.IsBusy;
        }


        /// <summary>
        /// Applies the search filter to the loaded log lines.
        /// </summary>
        [ACMethodCommand("", "en{'Apply Filter'}de{'Filter anwenden'}", 403)]
        public void ApplyFilter()
        {
            if (LogLines == null || LogLines.Count == 0)
            {
                Root.Messages.WarningAsync(this, "Please load a log file first.", true);
                return;
            }

            try
            {
                var filteredLines = new List<LogfileReaderLine>();

                if (string.IsNullOrWhiteSpace(SearchFilter))
                {
                    filteredLines.AddRange(LogLines);
                }
                else
                {
                    var filterLines = SearchFilter.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                    var filters = new List<(string source, string acName)>();

                    foreach (var filterLine in filterLines)
                    {
                        var parts = filterLine.Trim().Split(' ');
                        if (parts.Length >= 2)
                        {
                            filters.Add((parts[0], parts[1]));
                        }
                        else if (parts.Length == 1)
                        {
                            filters.Add((parts[0], string.Empty));
                        }
                    }

                    foreach (var logLine in LogLines)
                    {
                        foreach (var filter in filters)
                        {
                            bool sourceMatch = string.IsNullOrEmpty(filter.source) ||
                                             logLine.Source.IndexOf(filter.source, StringComparison.OrdinalIgnoreCase) >= 0;
                            bool acNameMatch = string.IsNullOrEmpty(filter.acName) ||
                                             logLine.ACName.IndexOf(filter.acName, StringComparison.OrdinalIgnoreCase) >= 0;

                            if (sourceMatch && acNameMatch)
                            {
                                filteredLines.Add(logLine);
                                break;
                            }
                        }
                    }
                }

                FilteredLogLines.Clear();
                foreach (var line in filteredLines.OrderBy(l => l.DateTime))
                {
                    FilteredLogLines.Add(line);
                }

                Root.Messages.InfoAsync(this, $"Filter applied. {FilteredLogLines.Count} lines match the criteria.", true);
            }
            catch (Exception ex)
            {
                Messages.LogException(this.GetACUrl(), "ApplyFilter", ex);
                Root.Messages.ErrorAsync(this, "Error applying filter: " + ex.Message, true);
            }
        }

        /// <summary>
        /// Creates and starts the selected analyzer.
        /// </summary>
        [ACMethodCommand("", "en{'Start Analysis'}de{'Analyse starten'}", 404)]
        public async void StartAnalysis()
        {
            if (SelectedAnalyzer == null)
            {
                await Root.Messages.WarningAsync(this, "Please select an analyzer first.", true);
                return;
            }

            if (FilteredLogLines == null || FilteredLogLines.Count == 0)
            {
                await Root.Messages.WarningAsync(this, "Please load and filter log lines first.", true);
                return;
            }

            CloseTopDialog();
            BackgroundWorker.RunWorkerAsync(nameof(DoAnalysis));
            await ShowDialogAsync(this, DesignNameProgressBar);
        }

        /// <summary>
        /// Checks if the Start Analysis command is enabled.
        /// </summary>
        public bool IsEnabledStartAnalysis()
        {
            return CurrentAnalyzerInstance != null && FilteredLogLines != null && FilteredLogLines.Count > 0 && CurrentAnalyzerInstance.IsEnabledStartAnalysis() && !BackgroundWorker.IsBusy;
        }


        [ACMethodCommand("", "en{'Select Output File'}de{'Ausgabedatei auswählen'}", 405)]
        public virtual void SelectOutputFile()
        {
            if (!IsEnabledSelectOutputFile())
                return;
            CurrentAnalyzerInstance.SelectOutputFile();
            OnPropertyChanged(nameof(OutputFilePath));
        }

        public bool IsEnabledSelectOutputFile()
        {
            return CurrentAnalyzerInstance != null;
        }

        #endregion

        #region Private Methods

        public override void BgWorkerDoWork(object sender, DoWorkEventArgs e)
        {
            base.BgWorkerDoWork(sender, e);
            ACBackgroundWorker worker = sender as ACBackgroundWorker;
            string command = e.Argument.ToString();
            worker.ProgressInfo.ProgressInfoIsIndeterminate = false;
            worker.ProgressInfo.OnlyTotalProgress = true;
            switch (command)
            {
                case nameof(ParseLogFile):
                    e.Result = ParseLogFile();
                    break;
                case nameof(DoAnalysis):
                    DoAnalysis();
                    break;
            }
        }

        public override void BgWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            base.BgWorkerCompleted(sender, e);
            CloseWindow(this, DesignNameProgressBar);
            ACBackgroundWorker worker = sender as ACBackgroundWorker;
            string command = worker.EventArgs.Argument.ToString();

            if (e.Cancelled)
            {
                //SendMessage(new Msg() { MessageLevel = eMsgLevel.Info, Message = string.Format(@"Operation {0} canceled by user!", command) });
            }
            if (e.Error != null)
            {
                //SendMessage(new Msg() { MessageLevel = eMsgLevel.Error, Message = string.Format(@"Error by doing {0}! Message:{1}", command, e.Error.Message) });
            }
            else
            {
                switch (command)
                {
                    case nameof(ParseLogFile):
                        LogLines.Clear();
                        List<LogfileReaderLine> logLines = e.Result as List<LogfileReaderLine>;
                        if (logLines != null)
                        {
                            foreach (var logLine in logLines.OrderBy(l => l.DateTime))
                            {
                                LogLines.Add(logLine);
                            }
                        }
                        break;
                    case nameof(DoAnalysis):
                        break;
                }
            }
        }

        private List<LogfileReaderLine> ParseLogFile()
        {
            var lines = File.ReadAllLines(SelectedLogFile);
            var logLines = new List<LogfileReaderLine>();
            CurrentProgressInfo.TotalProgress.ProgressRangeFrom = 0;
            CurrentProgressInfo.TotalProgress.ProgressRangeTo = lines.Length;

            for (int i = 0; i < lines.Length; i++)
            {
                try
                {
                    var logLine = ParseLogLine(lines[i]);
                    if (logLine != null)
                    {
                        logLines.Add(logLine);
                    }
                    CurrentProgressInfo.TotalProgress.ProgressCurrent = i;
                }
                catch (Exception ex)
                {
                    Messages.LogException(this.GetACUrl(), $"ParseLogFile_Line_{i}",
                        $"Error parsing line {i}: {lines[i]}. Exception: {ex.Message}");
                }

                // Update progress
                if (i % 1000 == 0)
                {
                    ProcessingProgress = (int)((double)i / lines.Length * 100);
                }
            }
            return logLines;
        }

        protected void DoAnalysis()
        {
            try
            {
                // Create new analyzer instance
                string analyzerID = SelectedAnalyzer.Value as string;
                if (_CurrentAnalyzerInstance != null)
                {
                    var lines = FilteredLogLines.ToList();
                    CurrentProgressInfo.TotalProgress.ProgressRangeFrom = 0;
                    CurrentProgressInfo.TotalProgress.ProgressRangeTo = lines.Count;
                    _CurrentAnalyzerInstance.SetLogLines(lines);
                    _CurrentAnalyzerInstance.StartAnalysis(DoAnalysisProgressCallback);
                }
            }
            catch (Exception ex)
            {
                Messages.LogException(this.GetACUrl(), "StartAnalysis", ex);
                Root.Messages.ErrorAsync(this, "Error starting analysis: " + ex.Message, true);
            }
        }


        private void DoAnalysisProgressCallback(int current, int count)
        {
            if (current == 0)
                CurrentProgressInfo.TotalProgress.ProgressRangeTo = count;
            CurrentProgressInfo.ReportProgress("DoAnalysis", current);
            CurrentProgressInfo.TotalProgress.ProgressText = string.Format(@"DoAnalysis: [{0}] | Progress: {1} / {2} steps...", _CurrentAnalyzerInstance?.ACCaption, current, count);
        }


        private LogfileReaderLine ParseLogLine(string line)
        {
            if (string.IsNullOrWhiteSpace(line))
                return null;

            try
            {
                // Expected format: {DateTime:yyyy-MM-dd-HH:mm:ss.ffff} {MessageLevel} {Source} {ACName} {Message}
                var parts = line.Split(' ');
                if (parts.Length < 5)
                    return null;

                // Parse DateTime
                if (!DateTime.TryParseExact(parts[0], "yyyy-MM-dd-HH:mm:ss.ffff", null, System.Globalization.DateTimeStyles.None, out DateTime dateTime))
                    return null;

                // Parse MessageLevel
                if (!Enum.TryParse<eMsgLevel>(parts[1], out eMsgLevel messageLevel))
                    return null;

                // Extract Source, ACName, and Message
                string source = parts[2];
                string acName = parts[3];
                string message = string.Join(" ", parts.Skip(4));

                return new LogfileReaderLine
                {
                    DateTime = dateTime,
                    MessageLevel = messageLevel,
                    Source = source,
                    ACName = acName,
                    Message = message,
                    OriginalLine = line
                };
            }
            catch
            {
                return null;
            }
        }

        private void LoadAvailableAnalyzers()
        {
            try
            {
                AvailableAnalyzers.Clear();
                foreach (var analyzerType in FindChildComponents<ACBSOLogfileAnalyzerBase>(c => c is ACBSOLogfileAnalyzerBase))
                {
                    AvailableAnalyzers.Add(new ACValueItem(analyzerType.ACCaption, analyzerType.ACIdentifier, null));
                }
            }
            catch (Exception ex)
            {
                Messages.LogException(this.GetACUrl(), "LoadAvailableAnalyzers", ex);
            }
        }

        #endregion

        #region HandleExecuteACMethod

        protected override bool HandleExecuteACMethod(out object result, AsyncMethodInvocationMode invocationMode, string acMethodName, core.datamodel.ACClassMethod acClassMethod, params object[] acParameter)
        {
            result = null;
            switch (acMethodName)
            {
                case nameof(SelectLogFile):
                    _= SelectLogFile();
                    return true;
                case nameof(LoadLogFile):
                    LoadLogFile();
                    return true;
                case nameof(ApplyFilter):
                    ApplyFilter();
                    return true;
                case nameof(StartAnalysis):
                    StartAnalysis();
                    return true;
                case nameof(IsEnabledStartAnalysis):
                    result = IsEnabledStartAnalysis();
                    return true;
                case nameof(IsEnabledLoadLogFile):
                    result = IsEnabledLoadLogFile();
                    return true;
                case nameof(SelectOutputFile):
                    SelectOutputFile();
                    return true;
            }
            return base.HandleExecuteACMethod(out result, invocationMode, acMethodName, acClassMethod, acParameter);
        }

        #endregion
    }

}